<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>int和Integer区别 | 一个Java程序猿的养成计划</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/study/assets/css/0.styles.87b2f6ed.css" as="style"><link rel="preload" href="/study/assets/js/app.4dbd6f0e.js" as="script"><link rel="preload" href="/study/assets/js/3.9cc2d08d.js" as="script"><link rel="preload" href="/study/assets/js/1.66bfa7cb.js" as="script"><link rel="preload" href="/study/assets/js/21.23c92e60.js" as="script"><link rel="prefetch" href="/study/assets/js/10.a437c854.js"><link rel="prefetch" href="/study/assets/js/11.7e8bf7a1.js"><link rel="prefetch" href="/study/assets/js/12.09c44073.js"><link rel="prefetch" href="/study/assets/js/13.c7888e0c.js"><link rel="prefetch" href="/study/assets/js/14.bb2fe56a.js"><link rel="prefetch" href="/study/assets/js/15.21436c98.js"><link rel="prefetch" href="/study/assets/js/16.c6b3596b.js"><link rel="prefetch" href="/study/assets/js/17.a3341c0c.js"><link rel="prefetch" href="/study/assets/js/18.b3dcfac9.js"><link rel="prefetch" href="/study/assets/js/19.f4dfb1a4.js"><link rel="prefetch" href="/study/assets/js/20.8fadd620.js"><link rel="prefetch" href="/study/assets/js/22.5a543cd8.js"><link rel="prefetch" href="/study/assets/js/23.019541e8.js"><link rel="prefetch" href="/study/assets/js/24.543388fc.js"><link rel="prefetch" href="/study/assets/js/25.98f971c9.js"><link rel="prefetch" href="/study/assets/js/26.f1d664d2.js"><link rel="prefetch" href="/study/assets/js/27.86a549d1.js"><link rel="prefetch" href="/study/assets/js/28.6c49cff5.js"><link rel="prefetch" href="/study/assets/js/4.979f9922.js"><link rel="prefetch" href="/study/assets/js/5.dda74e2f.js"><link rel="prefetch" href="/study/assets/js/6.5eed2fc3.js"><link rel="prefetch" href="/study/assets/js/7.8f40985b.js"><link rel="prefetch" href="/study/assets/js/8.e3dca3e1.js"><link rel="prefetch" href="/study/assets/js/9.df0b5501.js">
    <link rel="stylesheet" href="/study/assets/css/0.styles.87b2f6ed.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>一个Java程序猿的养成计划</h3> <p class="description" data-v-59e6cb88>Just playing around</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/study/" class="home-link router-link-active"><!----> <span class="site-name">一个Java程序猿的养成计划</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/study/" class="nav-link"><i class="undefined"></i>
  导航
</a></div><div class="nav-item"><a href="/study/pages/interview/index.html" class="nav-link"><i class="undefined"></i>
  面试
</a></div><div class="nav-item"><a href="/study/guide/d.html" class="nav-link"><i class="undefined"></i>
  导读
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      语言
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/language/chinese/" class="nav-link"><i class="undefined"></i>
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/study/language/japanese/" class="nav-link"><i class="undefined"></i>
  Japanese
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Java
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java基础知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/jajv.html" class="nav-link"><i class="undefined"></i>
  java基础知识提升和
</a></li><li class="dropdown-subitem"><a href="/study/kjk.html" class="nav-link"><i class="undefined"></i>
  java面试提升
</a></li></ul></li><li class="dropdown-item"><h4>Java知识提升</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/jkjj.html" class="nav-link"><i class="undefined"></i>
  Java提升-io
</a></li><li class="dropdown-subitem"><a href="/study/ksjdfkj.html" class="nav-link"><i class="undefined"></i>
  Java提升-kj
</a></li></ul></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>11</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/study/" class="nav-link"><i class="undefined"></i>
  导航
</a></div><div class="nav-item"><a href="/study/pages/interview/index.html" class="nav-link"><i class="undefined"></i>
  面试
</a></div><div class="nav-item"><a href="/study/guide/d.html" class="nav-link"><i class="undefined"></i>
  导读
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      语言
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/language/chinese/" class="nav-link"><i class="undefined"></i>
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/study/language/japanese/" class="nav-link"><i class="undefined"></i>
  Japanese
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      Java
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java基础知识</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/jajv.html" class="nav-link"><i class="undefined"></i>
  java基础知识提升和
</a></li><li class="dropdown-subitem"><a href="/study/kjk.html" class="nav-link"><i class="undefined"></i>
  java面试提升
</a></li></ul></li><li class="dropdown-item"><h4>Java知识提升</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/study/jkjj.html" class="nav-link"><i class="undefined"></i>
  Java提升-io
</a></li><li class="dropdown-subitem"><a href="/study/ksjdfkj.html" class="nav-link"><i class="undefined"></i>
  Java提升-kj
</a></li></ul></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/pages/java/basis/" class="sidebar-link">基础知识</a></li><li><a href="/study/pages/java/jvm/" class="sidebar-link">JVM</a></li><li><a href="/study/pages/java/thread/" class="sidebar-link">多线程</a></li><li><a href="/study/pages/java/IO/" class="sidebar-link">I/O</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Spring</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>框架|中间件</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>分布式解决方案</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>底层知识体系</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88></h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">int和Integer区别</h1> <div data-v-8a445198><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h2 id="int和integer区别"><a href="#int和integer区别" class="header-anchor">#</a> int和Integer区别</h2> <ul><li>int是基础类型，Integer是包装类型</li> <li>非new创建的类型在-128到127范围内使用==比较值相等时返回true</li> <li>new创建的类型使用==比较值相等时返回false</li> <li>非new和new创建的类型使用==比较值相等时返回false</li> <li>Java在编译Integer i=10;时，会翻译成Integer i=Integer.valueOf(10);</li> <li>int变量和new创建类型比较时，返回true</li> <li>new创建的类型是引用类型</li> <li>new创建的Integer类型在与int类型比较时，会自动拆箱成基础数据类型</li> <li>Java中存在两种类型：基础数据类型和引用类型</li> <li>非new创建的类型在-128到127时使用的是静态常量池中缓存数组中存储的指向堆中的Integer对象</li> <li>自动拆箱为引用类型转化为基础数据类型</li> <li>自动装箱为基础数据类型转化为引用类型</li></ul> <h2 id="类型详解"><a href="#类型详解" class="header-anchor">#</a> 类型详解</h2> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">类型名称</th> <th style="text-align:center;">关键字</th> <th style="text-align:center;">占用内存</th> <th style="text-align:center;">取值范围</th> <th style="text-align:center;">默认值</th></tr></thead> <tbody><tr><td style="text-align:center;">整型</td> <td style="text-align:center;">字节型</td> <td style="text-align:center;">byte</td> <td style="text-align:center;">1字节</td> <td style="text-align:center;">-128（-2^7)~127(2^7-1)</td> <td style="text-align:center;">0</td></tr> <tr><td style="text-align:center;">整型</td> <td style="text-align:center;">短整型</td> <td style="text-align:center;">short</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">-32768（-2^15）~32767(2^15-1)</td> <td style="text-align:center;">0</td></tr> <tr><td style="text-align:center;">整型</td> <td style="text-align:center;">整型</td> <td style="text-align:center;">int</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">-2147483648(-2^31)~2147483647(2^31-1)</td> <td style="text-align:center;">0</td></tr> <tr><td style="text-align:center;">整型</td> <td style="text-align:center;">长整型</td> <td style="text-align:center;">long</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">-9223372036854775808（-2^63)~9223372036854775807(2^63-1)</td> <td style="text-align:center;">0L</td></tr> <tr><td style="text-align:center;">浮点型</td> <td style="text-align:center;">单精度浮点型</td> <td style="text-align:center;">float</td> <td style="text-align:center;">4字节</td> <td style="text-align:center;">-3.403E38-3.403E38</td> <td style="text-align:center;">0.0F</td></tr> <tr><td style="text-align:center;">浮点型</td> <td style="text-align:center;">双精度浮点型</td> <td style="text-align:center;">double</td> <td style="text-align:center;">8字节</td> <td style="text-align:center;">-1.798E308~1.798E308</td> <td style="text-align:center;">0.0D</td></tr> <tr><td style="text-align:center;">字符型</td> <td style="text-align:center;">字符型</td> <td style="text-align:center;">char</td> <td style="text-align:center;">2字节</td> <td style="text-align:center;">表示一个字符，如（‘a','A','家')</td> <td style="text-align:center;">'\u0000'</td></tr> <tr><td style="text-align:center;">布尔型</td> <td style="text-align:center;">布尔型</td> <td style="text-align:center;">boolean</td> <td style="text-align:center;">1字节</td> <td style="text-align:center;">只有两个值，true或false</td> <td style="text-align:center;">false</td></tr> <tr><td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td> <td style="text-align:center;"></td></tr></tbody></table> <h2 id="修饰符访问权限"><a href="#修饰符访问权限" class="header-anchor">#</a> 修饰符访问权限</h2> <table><thead><tr><th style="text-align:center;">修饰符</th> <th style="text-align:center;">当前类</th> <th style="text-align:center;">同包</th> <th style="text-align:center;">子类</th> <th style="text-align:center;">其他包</th></tr></thead> <tbody><tr><td style="text-align:center;">private</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">不可以</td> <td style="text-align:center;">不可以</td> <td style="text-align:center;">不可以</td></tr> <tr><td style="text-align:center;">default</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">不可以</td> <td style="text-align:center;">不可以</td></tr> <tr><td style="text-align:center;">protected</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">不可以</td></tr> <tr><td style="text-align:center;">public</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td> <td style="text-align:center;">可以</td></tr></tbody></table> <h2 id="jvm、jre和jdk的关系"><a href="#jvm、jre和jdk的关系" class="header-anchor">#</a> JVM、JRE和JDK的关系</h2> <ul><li>JVM是java Virtual Machine（Java虚拟机 ），Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台</li> <li>JRE是Java runtime Environment（Java运行库），包括Java虚拟机和Java程序所需的核心类库，核心类库主要是Java.lang包，运行一个Java程序，只需要安装jre即可。</li> <li>JDK是java Development Kit(java 开发工具)，是Java的开发工具，其中也包含了jre，所以安装了jdk就无需单独安装jre，其中jdk的开发工具包含：编译工具javac.exe,打包工具jar.exe等</li> <li>JDK&gt;JRE&gt;JVM</li></ul> <h2 id="java字节码文件"><a href="#java字节码文件" class="header-anchor">#</a> Java字节码文件</h2> <ul><li>Java源代码经过虚拟机编译后产生的文件.class，不面向任何特定处理器，只面向虚拟机</li> <li>采用字节码的好处
<ul><li>一定程度上解决了传统解释型语言执行效率低的问题，同时保留解释型语言可移植的特定</li> <li>每一种平台的解释器是不同的，但是实现的虚拟机是相同的</li> <li>解释器在jvm中</li> <li>Java源代码------&gt;编译器-------&gt;jvm可执行的Java字节码（即虚拟指令）-----&gt;jvm-----&gt;jvm中解释器------&gt;机器可执行的二进制机器码------&gt;程序运行</li></ul></li></ul> <h2 id="java和c-的区别"><a href="#java和c-的区别" class="header-anchor">#</a> Java和C++的区别</h2> <ul><li>都是面向对象语言，都支持封装、继承和多态</li> <li>Java不提供指针来直接访问内存，程序内存更加安全</li> <li>Java类是单继承，c++支持多继承；Java接口支持多继承</li> <li>Java有自动内存管理机制（垃圾回收机制），不需要程序员手动释放无用内存</li></ul> <h2 id="oracle-jdk和open-jdk对比"><a href="#oracle-jdk和open-jdk对比" class="header-anchor">#</a> oracle jdk和open jdk对比</h2> <ul><li>oracle jdk版本每三年发布一次，open jdk每三个月发布一次</li> <li>open jdk是一个参考模型并且完全开源，oracle jdk是open jdk的一个实现，并不是完全开源</li> <li>oracle jdk比open jdk更稳定，两者代码几乎相同，如果想开发企业级软件，建议使用oracle jdk</li> <li>在响应和性能方面，oracle jdk比open jdk提供了更好的性能</li> <li>oracle jdk根据二进制代码许可协议获得许可，而open jdk根据GPL v2许可后的许可</li></ul> <h2 id="java数据类型"><a href="#java数据类型" class="header-anchor">#</a> java数据类型</h2> <ul><li><p>基本数据类型</p> <ul><li><p>数值型</p> <blockquote><p>整数类型（byte、short、int、long）</p> <p>浮点类型（float、double）</p> <p>字符型（char）</p> <p>布尔型（boolean）</p></blockquote></li> <li><p>引用数据类型</p> <blockquote><p>类（class）</p> <p>接口（interface）</p> <p>数组（[]）</p></blockquote></li></ul></li></ul> <h2 id="switch作用类型"><a href="#switch作用类型" class="header-anchor">#</a> switch作用类型</h2> <ul><li>在Java 5以前，switch（expr)，expr只能是byte、short、char、int类型，在Java 5开始，引入了枚举类型，Java 7之后expr还可以是字符串类型，但是任何版本都不支持long类型</li></ul> <h2 id="四舍五入原理"><a href="#四舍五入原理" class="header-anchor">#</a> 四舍五入原理</h2> <ul><li>在参数上加上0.5然后进行下取整</li></ul> <h2 id="java语言采用的编码方案"><a href="#java语言采用的编码方案" class="header-anchor">#</a> Java语言采用的编码方案</h2> <ul><li>采用Unicode编码标准</li> <li>Unicode(标准码)：为每个字符制定了一个唯一的数值</li> <li>在任何语言，平台、程序都可以放心使用</li></ul> <h2 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h2> <ul><li>单行注释 ：//</li> <li>多行注释：/*  */</li> <li>文档注释：/**  */</li></ul> <h2 id="final"><a href="#final" class="header-anchor">#</a> final</h2> <ul><li>用作修饰类、属性和方法
<ul><li>被final修饰的类不可以被继承</li> <li>被final修饰的方法不可以被重写</li> <li>被final修饰的变量不可以被改写</li> <li>被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</li></ul></li></ul> <h2 id="final-finally-finalize区别"><a href="#final-finally-finalize区别" class="header-anchor">#</a> final finally finalize区别</h2> <ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承，修饰方法表示该方法不能被重写，修饰变量表示该变量是一个常量不能被重新赋值</li> <li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法放在finally块中，表示不管是否出现异常，该代码都会执行，一般用来存放一些关闭资源的代码</li> <li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc()方法时，由垃圾回收器调用finalize(),回收垃圾，一个对象是否可回收的最后判断</li></ul> <h2 id="this关键字"><a href="#this关键字" class="header-anchor">#</a> this关键字</h2> <ul><li><p>普通直接饮用，this相当于是指向当前对象本身</p></li> <li><p>形参与成员名字重用，用this来区分：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
 <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div></li> <li><p>饮用本类的构造函数</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token operator">=</span>age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="super"><a href="#super" class="header-anchor">#</a> super</h2> <ul><li><p>指向自己父类对象的一个指针，而这个父类指的是离自己最近的一个父类</p></li> <li><p>普通的直接引用，相当于是指向当前对象的父类的引用，可以用super.xxx来引用父类的成员</p></li> <li><p>子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">protected</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span><span class="token class-name">String</span> name1<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token operator">=</span>name1<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>引用父类构造函数</p></li></ul> <h2 id="this和super的区别"><a href="#this和super的区别" class="header-anchor">#</a> this和super的区别</h2> <ul><li>super引用当前对象的直接父类的成员</li> <li>this指当前对象</li> <li>super()和this()类似，区别是super()在子类中调用父类构造方法，this()在本类内调用本类的其他构造方法。</li> <li>super()和this()均需要放在构造函数方法内第一行</li> <li>同一个构造函数中，只能只用this()调用一个构造方法</li> <li>this和super不能同时出现在一个构造函数，因为super()和this()需要放在方法内第一行</li> <li>this和super都指向对象，所以均不可以放在static环境中使用</li> <li>从本质上讲，this是一个指向本对象的指针，然而super是一个Java关键字</li></ul> <h2 id="static"><a href="#static" class="header-anchor">#</a> static</h2> <ul><li>在类初次被加载时，会按照static块的顺序来执行每个static块，并且只会执行一次</li> <li>被static修饰的变量或方法独立于该类的任何对象，被该类的所有实例共享</li> <li>static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配，可以任意赋值</li> <li>被static修饰的变量或方法是优先于对象存在的，当一个类加载完毕之后，即使没有创建对象，也可以去访问</li> <li>static可以修饰成员变量、成员方法，代码块、内部类</li> <li>static方法只能访问静态方法，非static方法既可以访问static方法也可以访问非static方法。</li></ul> <h2 id="break、continue、return"><a href="#break、continue、return" class="header-anchor">#</a> break、continue、return</h2> <ul><li>break跳出总上一层循环，不再执行循环（结束当前的循环体）</li> <li>continue跳出本次循环，继续执行下次循环（结束正在执行的循环，进入下一个循环条件)</li> <li>return程序返回，不再执行下面的代码（结束当前方法，直接返回）</li></ul> <h2 id="跳出当前多重循环嵌套"><a href="#跳出当前多重循环嵌套" class="header-anchor">#</a> 跳出当前多重循环嵌套</h2> <div class="language-java extra-class"><pre class="language-java"><code> ok<span class="token operator">:</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token keyword">break</span> ok<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
</code></pre></div><h2 id="抽象"><a href="#抽象" class="header-anchor">#</a> 抽象</h2> <ul><li>是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注行为的细节</li></ul> <h2 id="封装"><a href="#封装" class="header-anchor">#</a> 封装</h2> <ul><li>把一个对象的属性私有化，同时提供一些可以被外界访问的属性和方法</li> <li>隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性</li></ul> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <ul><li>使用已存在的类的定义作为基础建立新类的技术</li> <li>子类拥有父类非private的属性和方法</li> <li>子类可以拥有自己的属性和方法，即子类对父类的扩展</li> <li>子类可以用自己的方式实现父类的方法</li></ul> <h2 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h2> <ul><li>两种形式实现：继承（多个子类对父类同一个方法的重写）和接口（实现接口并覆写接口中同一方法）</li> <li>方法重写：子类继承父类并重写父类中已有的或抽象方法</li> <li>对象构造（用父类类型引用子类类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为</li></ul> <h2 id="五大基本原则"><a href="#五大基本原则" class="header-anchor">#</a> 五大基本原则</h2> <ul><li>单一职责SRP（Single Responsibility Principle）类功能要单一，不能包罗万象</li> <li>开放封闭原则OCP（Open Close Principle）一个模块对于拓展是开放的，对于修改是封闭的</li> <li>里式替换原则LSP（the Liskov Substitution Principle）子类可以替代父类出现在父类能够出现的任何地方</li> <li>依赖倒置原则DIP（the Dependency Inversion Principle）高层次的模块不应该依赖于低层次的模块，都应该依赖于抽象，抽象不应该依赖于具体实现，具体实现应该依赖于抽象</li> <li>接口分离原则ISP（the Interface Segregation Principle）设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。一个接口只有一种功能</li></ul> <h2 id="抽象类和接口"><a href="#抽象类和接口" class="header-anchor">#</a> 抽象类和接口</h2> <ul><li>相同点
<ul><li>都不能实例化</li> <li>都位于继承的顶端，用于被其他实现或继承</li> <li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul></li> <li>不同点
<ul><li>抽象类使用abstract关键字声明，接口使用interface关键字声明</li> <li>子类使用extends关键字来继承，如果子类不是抽象类，需要实现父类所有抽象方法；子类使用implements关键字实现接口，需要实现所有接口中方法</li> <li>抽象类可以有构造器，接口没有构造器</li> <li>抽象类可以是任意访问修饰符，接口默认是public，且只能是public</li> <li>一个类只能继承一个抽象类，一个类可以实现多个接口</li> <li>抽象类的字段声明可以是任意的，接口的字段默认都是static和final的</li></ul></li></ul> <h2 id="实例和引用区别"><a href="#实例和引用区别" class="header-anchor">#</a> 实例和引用区别</h2> <ul><li>new创建对象实例，对象实例存放在堆内存中</li> <li>对象引用指向对象实例，对象引用存放在栈内存中</li> <li>一个对象引用可以指向0个或一个对象，一个对象可以被n个引用指向</li></ul> <h2 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h2> <ul><li>种类：成员内部类、局部内部类、匿名内部类和静态内部类</li> <li>成员内部类
<ul><li>定义在类内部的类</li> <li>可以使用外部类的所有变量和方法，包括静态和费静态，私有和公有</li> <li>依赖外部类实例，创建实例为：外部类实例.new  内部类()</li></ul></li> <li>局部内部类
<ul><li>定义在方法内部的类</li> <li>定义在实例方法的局部内部类可以访问外部类的所有变量和方法</li> <li>定义在静态方法的局部类只能方法外部类的静态方法和变量</li></ul></li> <li>匿名内部类
<ul><li>匿名内部类必须继承一个抽象类或者实现一个接口</li> <li>匿名内部类不能定义任何静态成员和静态方法</li> <li>所在的方法的形参需要被匿名内部类使用时，必须生命为final</li> <li>匿名内部类不能是抽象的，必须实现继承的类或者实现的接口所有方法</li> <li>局部变量加上final是因为生命周期不同，方法执行结束，局部变量就销毁，而局部内部类对局部变量的引用依然存在，此时就会出错</li></ul></li></ul> <h2 id="和equals的区别"><a href="#和equals的区别" class="header-anchor">#</a> ==和equals的区别</h2> <ul><li>==：判断两个对象的地址是否相等，即判断两个对象是不是同一个对象（基本数据类型比较的是值，引用数据类型比较的是内存地址）</li> <li>equals：判断两个对象是否相等，有两种情况:
<ul><li>1.类没有覆盖equals方法，则比较该类的两个对象的内存地址，等价==</li> <li>类覆盖了equals方法，一般是两个对象的内容相等，则认为这两个对象相等</li></ul></li></ul> <h2 id="string类型"><a href="#string类型" class="header-anchor">#</a> String类型</h2> <ul><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋值给当前引用，没有就在常量池中重新创建一个对象</li></ul> <h2 id="hashcode与equals"><a href="#hashcode与equals" class="header-anchor">#</a> hashCode与equals</h2> <ul><li>hashCode方法作用是获取哈希码，也称为散列码</li> <li>如果两个对象相等，则hashcode一定也是相同的</li> <li>对两个对象分别调用equals方法都返回true，两个对象有相同的hashcode值，他们也不一定是相等的</li> <li>对象相等比较的是内存中存放的内容是否相等，引用相等比较的是它们指向的内存地址是否相等</li></ul> <h2 id="值传递"><a href="#值传递" class="header-anchor">#</a> 值传递</h2> <ul><li>方法调用只支持值传递，当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。</li></ul> <h2 id="java包"><a href="#java包" class="header-anchor">#</a> java包</h2> <ul><li>java.lang：系统基础类</li> <li>java.io :所有输入输出有关的类，比如文件操作</li> <li>java.nio:完善io包功能，提高io包性能</li> <li>java.net:与网络有关的类</li> <li>java.util:系统辅助类，特别是集合类</li> <li>java.sql:数据库操作类</li></ul> <h2 id="bio、nio、aio"><a href="#bio、nio、aio" class="header-anchor">#</a> BIO、NIO、AIO</h2> <ul><li>BIO（Blocking I/O）：同步阻塞I/O模式，数据的读写必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这个模式可以承受，当面对十万甚至百万级连接时，传统BIO是无能为力的。</li> <li>NIO(New I/O)：NIO是一种同步非阻塞的I/O模型，对应java.nio包，提供Channel、Selector、Buffer等抽象，NIO中N可以理解为Non-blocking，支持面向缓冲，基于通道的I/O操作方法，NIO提供SocketChannel和ServerSocketChannel两种不同的套接字通道实现，且都支持阻塞和非阻塞两种模式。</li> <li>AIO（Asynchronous I/O）：异步非阻塞的IO模型，异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会阻塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</li></ul> <h2 id="files的常用方法"><a href="#files的常用方法" class="header-anchor">#</a> Files的常用方法</h2> <ul><li>Files.exists():检测文件路径是否存在</li> <li>Files.createFile():创建文件</li> <li>Files.createDirectory():创建文件夹</li> <li>Files.delete():删除一个文件或目录</li> <li>Files.copy():复制文件</li> <li>Files.move()：移动文件</li> <li>Files.size()：查看文件个数</li> <li>Files.read()：读取文件</li> <li>Files.write()：写入文件</li></ul> <h2 id="反射"><a href="#反射" class="header-anchor">#</a> 反射</h2> <ul><li><p>实现反射</p> <ul><li>通过new对象getClass()方法</li> <li>通过路径实现反射机制：Class.forName(&quot;fanshe.Student&quot;)</li> <li>通过类名实现反射机制：Student.class</li></ul></li> <li><p>优点</p> <ul><li>运行期类型的判断，动态加载类，提高代码灵活度</li></ul></li> <li><p>缺点</p> <ul><li>性能比直接的java代码要慢的多</li></ul></li></ul> <h2 id="数组没有length-有length属性-string有length"><a href="#数组没有length-有length属性-string有length" class="header-anchor">#</a> 数组没有length(),有length属性，String有length()</h2> <h2 id="string-类常用方法"><a href="#string-类常用方法" class="header-anchor">#</a> String 类常用方法</h2> <ul><li>indexOf():返回指定字符的索引</li> <li>charAt():返回指定索引处的字符</li> <li>replace():字符串替换</li> <li>trim():去除字符串两端空白</li> <li>split():分割字符串，返回一个分割后的字符串数据</li> <li>getBytes():返回字符串的byte类型数组</li> <li>length():返回字符串长度</li> <li>toLowerCase():将字符串转成小写字符</li> <li>toUpperCase():将字符串转成大写字符</li> <li>substring()：截取字符串</li> <li>equals：字符串比较</li></ul> <h2 id="hashmap使用string做key好处"><a href="#hashmap使用string做key好处" class="header-anchor">#</a> HashMap使用string做key好处</h2> <blockquote><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。</p></blockquote> <h2 id="string、stringbuffer、stringbuilder"><a href="#string、stringbuffer、stringbuilder" class="header-anchor">#</a> String、StringBuffer、StringBuilder</h2> <ul><li>String类中使用final char value[]，所以string对象不可变，其他两种可变</li> <li>运行速度不同：StringBuilder&gt;StringBuffer&gt;String
<ul><li>string对象值不可变，所以修改值会重新创建新的对象</li> <li>StringBuilder没有加锁操作，StringBuffer有加锁操作</li></ul></li> <li>StringBuffer比StringBuilder线程更安全</li></ul> <hr> <h2 id="集合"><a href="#集合" class="header-anchor">#</a> 集合</h2> <ul><li><p>Map接口</p> <ul><li>HashMap类</li> <li>TreeMap类</li> <li>HashTable类</li> <li>LinkedHashMap类</li> <li>ConcurrentHashMap类</li></ul></li> <li><p>Collection接口</p> <ul><li>Set接口
<ul><li>HashSet（无序，唯一）：基于HashMap实现，底层采用HashMap来保存元素</li> <li>LinkedHashSet：继承HashSet，并且内部通过LinkedHashMap实现</li> <li>TreeSet(有序，唯一)：红黑树（自平衡的排序二叉树。）</li> <li>HashMap：jdk1.8之前由数组+链表组成，jdk1.8之后当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li> <li>LinkedHashMap：继承自HashMap，在这基础上增加了一条双向链表，使得可以保持键值对的插入顺序</li> <li>HashTable：数组加链表组成，数组是HashMap的主体，链表则主要是为了解决哈希冲突</li> <li>TreeMap：红黑树（自平衡的排序二叉树）</li></ul></li> <li>List接口
<ul><li>ArrayList:Object数组</li> <li>Vector：object数组</li> <li>LinkedList：双向循环链表</li></ul></li> <li>Queue接口</li></ul></li></ul> <h2 id="线程安全集合"><a href="#线程安全集合" class="header-anchor">#</a> 线程安全集合</h2> <ul><li>vector:比ArrayList多个同步化机制（线程安全），但因为效率低，所以不建议使用</li> <li>statck:堆栈类，先进后出</li> <li>hashtable：比hashmap多一个线程安全</li> <li>enumeration：枚举，相当于迭代器</li></ul> <h2 id="快速故障-fail-fast"><a href="#快速故障-fail-fast" class="header-anchor">#</a> 快速故障（fail-fast)</h2> <ul><li>例子：存在两个线程线程1、线程2），线程1通过Iterator在遍历集合A中 的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改（删除和新增），而不是简 单的修改集合元素的内容），那么这个时候程序就会抛出ConcurrentModificationException 异常，从而产生fail-fast机制。</li> <li>迭代器在遍历时直接访问集合的内容，并且在遍历过程中使用一个modCount（模数）变量，集合在被遍历过程中如果元素发生变化，就会改变modCount的值，每当迭代器使用hashnext和next遍历下一个元素之前都会检测modCount变量是否为expectedModCount（预期模数），是就返回遍历的值，否则抛出异常</li></ul> <h2 id="确保一个集合不能被修改"><a href="#确保一个集合不能被修改" class="header-anchor">#</a> 确保一个集合不能被修改</h2> <blockquote><div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">unmodifiableCollection</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></blockquote> <h2 id="迭代器-iterator"><a href="#迭代器-iterator" class="header-anchor">#</a> 迭代器 Iterator</h2> <ul><li>单向遍历</li> <li>可以边遍历边移除Collection中元素（iterator.remove()）</li></ul> <h2 id="arraylist和linklist"><a href="#arraylist和linklist" class="header-anchor">#</a> ArrayList和LinkList</h2> <ul><li>数据结构：前者为数组，后者为双向链表</li> <li>随机访问效率：数组随机访问效率高，链表随机访问效率低</li> <li>维护效率：在不是首尾位置维护，链表效率高于数组</li> <li>内存空间大小：链表比数组更占内存，因为链表除了存储数据，还要存储两个指针</li> <li>线程安全：两者都为非同步，都是线程不安全</li></ul> <h2 id="vector"><a href="#vector" class="header-anchor">#</a> Vector</h2> <ul><li>线程安全，添加synchronized</li> <li>数据结构为数组</li></ul> <h2 id="transient"><a href="#transient" class="header-anchor">#</a> transient</h2> <h2 id="list和set区别"><a href="#list和set区别" class="header-anchor">#</a> List和Set区别</h2> <ul><li>都继承自Collection接口</li> <li>前者有序容器，可以插入多个null元素，元素都有索引，常用实现类有ArrayList、LinkList和Vector；后者无序容器，不可以存储重复元素，只允许存入一个null元素，保证元素唯一性，常用实现类有HashSet、LinkedHashSet和TreeSet</li> <li>前者和数组类似，可以动态增长，查找效率高，维护效率低，后者检索元素效率低，维护效率高</li></ul> <h2 id="hashset查重"><a href="#hashset查重" class="header-anchor">#</a> HashSet查重</h2> <ul><li>不仅比较元素的hash值，同时还要比较equles</li></ul> <h2 id="hashcode和equals规则"><a href="#hashcode和equals规则" class="header-anchor">#</a> hashcode和equals规则</h2> <ul><li>如果两个对象相等，则hashcode一定相同</li> <li>两个对象相等，对两个equals方法返回true</li> <li>两个对象有相同的hashcode值，它们不一定相等</li> <li>equals方法被重写，hashcode方法也应该被重写</li> <li>hashcode默认行为是对堆上的对象产生独特值，如果没有重写hashcode，则该class的两个对象无论如何都不相等（即使这两个对象指向相同的数据）</li></ul> <h2 id="hashset和hashmap区别"><a href="#hashset和hashmap区别" class="header-anchor">#</a> HashSet和HashMap区别</h2> <ul><li>前者实现Set接口，后者实现Map接口</li> <li>前者存储对象，后者存储键值对</li> <li>前者调用add添加元素，后者调用put添加元素</li> <li>前者使用成员对象计算hashcode，后者使用键计算hashcode</li></ul> <h2 id="hashmap实现原理"><a href="#hashmap实现原理" class="header-anchor">#</a> HashMap实现原理</h2> <ul><li>基于数组和链表实现</li></ul> <h2 id="hashmap和hashtable"><a href="#hashmap和hashtable" class="header-anchor">#</a> HashMap和HashTable</h2> <ul><li>前者非线程安全，后者线程安全</li> <li>前者效率高，后者效率低</li> <li>前者null可以作为键，且只有一个，后者不允许存在null键</li> <li>前者初始大小为16，之后每次扩充为原来的2倍，后者初始大小为11，之后每次扩充为原来的2n+1</li></ul> <hr> <h4 id="错误"><a href="#错误" class="header-anchor">#</a> 错误</h4> <h2 id="throwable"><a href="#throwable" class="header-anchor">#</a> Throwable</h2> <ul><li>所有错误与异常的超类（父类）</li> <li>包含两种子类类型Error（错误）和Exception（异常）</li> <li>提供printStackTrace()等方法用于获取堆栈跟踪数据等信息</li></ul> <h2 id="error-错误"><a href="#error-错误" class="header-anchor">#</a> Error（错误）</h2> <ul><li>程序中无法处理的错误</li> <li>非代码性错误</li> <li>不应该实现任何新的Error子类</li></ul> <h2 id="exception-异常"><a href="#exception-异常" class="header-anchor">#</a> Exception（异常）</h2> <ul><li>程序可以捕获和处理的</li> <li>分为运行时异常和编译时异常</li> <li>运行时异常
<ul><li>表示JVM在运行期间可能出现的异常</li> <li>java编译器不会检查，如NullPointerException空指针异常</li> <li>由java虚拟机自动抛出并自动捕获</li> <li>代码本身逻辑问题</li></ul></li> <li>编译时异常
<ul><li>异常中除了运行时异常及其子类之外的异常</li> <li>java编译器会检测它，不能通过编译</li></ul></li></ul> <h2 id="受检异常和非受检异常"><a href="#受检异常和非受检异常" class="header-anchor">#</a> 受检异常和非受检异常</h2> <ul><li>java中所有异常分为受检异常和非受检异常</li> <li>受检异常
<ul><li>编译器要求必须处理的异常，不处理编译不通过，就是编译时异常</li></ul></li> <li>非受检异常
<ul><li>编译器不会检查的异常，就是运行时异常</li></ul></li></ul> <h2 id="异常处理关键字"><a href="#异常处理关键字" class="header-anchor">#</a> 异常处理关键字</h2> <ul><li>throw :抛出异常</li> <li>try catch finally  :捕获异常</li> <li>throws：声明异常</li></ul> <h2 id="自定义异常"><a href="#自定义异常" class="header-anchor">#</a> 自定义异常</h2> <ul><li>继承Exception类</li> <li>包含两个构造函数，一个无参构造函数和一个带有详细描述信息的构造函数，且调用父类的构造方法</li></ul> <h2 id="try-with-resource"><a href="#try-with-resource" class="header-anchor">#</a> try-with-resource</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">tryWithResourceTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">&quot;c:/abc&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;UTF8&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// code</span>
 <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">// handle exception</span>
	<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>上述代码在try代码块退出时自动调用scanner.close()方法</p></blockquote> <h2 id="jvm处理异常过程"><a href="#jvm处理异常过程" class="header-anchor">#</a> JVM处理异常过程</h2> <blockquote><p>一个方法中发生异常，方法会创建一个异常对象，转交给jvm，该异常对象包含异常名称、异常描述以及异常发生时应用程序的状态。</p> <p>创建异常对象转交给jvm的过程称为抛出异常，可能存在一系列的方法调用之后才进入抛出异常的方法，这一系列方法调用的有序列表叫做调用栈。</p> <p>jvm会顺着调用栈去查找是否有可以处理异常的代码，如果有，则调用异常处理代码，把发生的异常传递给它，如果jvm没有找到可以处理该异常的代码块，jvm就会将该异常转交给默认的异常处理器，默认异常处理器打印出异常信息并终止应用程序</p></blockquote> <h2 id="final、finally、finalize区别"><a href="#final、finally、finalize区别" class="header-anchor">#</a> final、finally、finalize区别</h2> <ul><li>final可以修饰类、变量、方法；依次表示类不能被继承、变量为常量、方法不能被重写</li> <li>finally用作try-catch代码块中，不管是否抛出异常，finally块的代码都会执行，一般存放释放关闭资源的代码</li> <li>finalize是一个方法，属于object类的方法，允许使用finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作</li></ul> <h2 id="try-catch-finally中哪部分可省略"><a href="#try-catch-finally中哪部分可省略" class="header-anchor">#</a> try-catch-finally中哪部分可省略</h2> <ul><li>catch可以省略</li> <li>原因为try适合处理运行时异常，try-catch适合处理运行时异常和编译时异常，处理编译时异常不加catch无法通过编译，但是处理运行时异常时没有这个规定，所以可以去掉catch。</li></ul> <h2 id="常见runtimeexception异常"><a href="#常见runtimeexception异常" class="header-anchor">#</a> 常见RuntimeException异常</h2> <ul><li>ClassCastException（类转换异常）</li> <li>IndexOutOfboundsException（数组越界异常）</li> <li>NullPointerException（空指针异常）</li> <li>ArrayStoreException（数据存储异常，操作数组时类型不一致）</li> <li>BufferOverflowException（IO操作异常）</li></ul> <h2 id="异常处理最佳实践"><a href="#异常处理最佳实践" class="header-anchor">#</a> 异常处理最佳实践</h2> <ul><li>在finally块中清理资源或者使用try-with-resource语句</li> <li>优先明确的异常</li> <li>对异常进行文档说明</li> <li>使用描述性消息抛出异常</li> <li>优先捕获最具体的异常</li> <li>不要捕获Throwable类</li> <li>不要忽略异常</li> <li>不要记录并抛出异常</li> <li>包装异常时不要抛弃原始异常</li> <li>不要使用异常控制程序流程</li> <li>使用标准异常</li> <li>异常影响性能</li> <li>异常性能低于判断语句性能</li></ul> <hr> <h4 id="并发"><a href="#并发" class="header-anchor">#</a> 并发</h4> <h2 id="并发三要素"><a href="#并发三要素" class="header-anchor">#</a> 并发三要素</h2> <ul><li>原子性：指一个或多个操作要么全部执行成功要么全部执行失败</li> <li>可见性：一个线程对共享变量的修改，另一个线程能够立刻看到（synchronized、volatile）</li> <li>有序性：程序执行的顺序按照代码的先后顺序执行。（处理器可能会对指令进行重排序）</li></ul> <h2 id="线程安全问题原因"><a href="#线程安全问题原因" class="header-anchor">#</a> 线程安全问题原因</h2> <ul><li>线程切换带来的原子性问题
<ul><li>JDk Atomic开头的原子类、synchronized、lock可以解决原子性问题</li></ul></li> <li>缓存导致的可见性问题
<ul><li>synchronized、volatile、lock可以解决可见性问题</li></ul></li> <li>编译优化带来的有序性问题
<ul><li>Happens-Before规则可以解决有序性问题</li></ul></li></ul> <h2 id="并行和并发"><a href="#并行和并发" class="header-anchor">#</a> 并行和并发</h2> <ul><li>并发：多个任务在同一个CPU核上，按细分的时间片轮流交替执行，从逻辑上来看那些任务是同时执行</li> <li>并行：单位时间内，多个处理器或多核处理器同时处理多个任务，是真正意义上的同时进行</li> <li>串行：有n个任务，有一个线程按顺序执行。由于任务、方法都在一个线程执行，所有不存在线程不安全情况，也就不存在临界区的问题</li> <li>形象比喻：并发=两个队列和一台咖啡机  ；并行=两个队列和两台咖啡机  ；串行=一个队列和一个咖啡机</li></ul> <h2 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h2> <ul><li>解释：多线程是指程序中包含多个执行流，在一个程序中可以同时运行多个不同的线程来执行不同的任务</li> <li>优势：可以提高cpu的利用率，在多线程程序中，一个线程必须等待的时候，cpu可以运行其他的线程而不是等待，这样就大大提高了程序的效率，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务</li> <li>劣势
<ul><li>线程也是程序，所以线程需要占用内存，线程越多占用内存越多</li> <li>多线程需要协调和管理，所以需要cpu时间跟踪线程</li> <li>线程之间对共享资源的访问会相互影响，必须解决竞争共享资源问题</li></ul></li></ul> <h2 id="线程和进程"><a href="#线程和进程" class="header-anchor">#</a> 线程和进程</h2> <ul><li>进程：一个在内存中运行的应用程序。每个进程有自己独立的一块内存空间，一个进程可以有多个线程</li> <li>线程：进程中的一个执行任务（控制单元），负责当前进程中程序的执行，一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可以共享数据</li> <li>区别
<ul><li>普通区别：线程具有许多传统进程所具有的特征，故又称为轻型进程或进程元，而把传统的进程称为重型进程，它相当于只有一个线程的任务。</li> <li>根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</li> <li>资源开销：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换开销小</li> <li>包含关系：如果一个进程内有多个线程，则执行过程不是一条线，而是多条线共同完成的</li> <li>内存分配：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</li> <li>影响关系：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉，所以多进程要比多线程健壮</li> <li>执行过程：每个独立的进程有程序运行的入口，顺序执行序列和程序出口，但是线程不能独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制，两者均可并发执行</li></ul></li></ul> <h2 id="上下文切换"><a href="#上下文切换" class="header-anchor">#</a> 上下文切换</h2> <ul><li>解释：多线程编程中一般线程的个数都大于CPU核心的个数，而一个cpu核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，cpu采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完时会重新处于就绪状态，cpu让给其他线程使用，这个过程就属于一次上下文切换 ；任务从保存到再加载的过程就是一次上下文切换。</li></ul> <h2 id="守护线程和用户线程"><a href="#守护线程和用户线程" class="header-anchor">#</a> 守护线程和用户线程</h2> <ul><li>前者运行在后台，为其他前台线程服务，也可以说守护线程是JVM中非守护线程的佣人，一旦所有用户线程都结束运行，守护线程会随着jvm一起结束工作</li> <li>后者运行在前台，执行具体的任务。</li> <li>注意事项
<ul><li>在守护线程中产生的新线程也是守护线程</li> <li>不是所有的任务都可以分配给守护线程来执行，比如读写操作或计算逻辑</li> <li>守护线程中不能依靠finally块的内容来确保执行关闭或清理资源逻辑，因为一旦用户线程结束，守护线程会立刻结束，所以finally块中代码可能无法执行</li></ul></li></ul> <h2 id="linux查找cpu利用率最高的线程"><a href="#linux查找cpu利用率最高的线程" class="header-anchor">#</a> linux查找cpu利用率最高的线程</h2> <blockquote><p>待补充</p></blockquote> <h2 id="线程死锁"><a href="#线程死锁" class="header-anchor">#</a> 线程死锁</h2> <ul><li>解释：两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象</li> <li>形成死锁必要条件
<ul><li>互斥条件：所谓互斥就是进程在某一时间内独占资源（线程对于所分配到的资源具有排他性，即一个资源只能被一个线程占用，直到被该线程释放）
<ul><li>破坏：无法破坏，用锁本来就是要互斥</li></ul></li> <li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放（一个线程因请求被占用资源而发生阻塞时，对于已获得的资源保持不放）
<ul><li>破坏：一次性申请所有的资源</li></ul></li> <li>不剥夺条件：线程已获得资源，在未使用完之前，不能强行剥夺（线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源）
<ul><li>破坏： 占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占用的资源</li></ul></li> <li>循环等待条件：若干线程之间形成一种头尾相接的循环等资源关系（当发生死锁时，所等待的线程必定会形成一个环路，造成永久阻塞）
<ul><li>破坏：靠按序申请资源来预防，按某一顺序申请资源，释放资源则反序释放。破坏循环等条件</li></ul></li></ul></li></ul> <h2 id="创建线程方法"><a href="#创建线程方法" class="header-anchor">#</a> 创建线程方法</h2> <ul><li>继承Thread类</li> <li>实现Runnable接口</li> <li>实现Callable接口</li> <li>使用Executors工具类创建线程池继承Thread类</li></ul> <h2 id="start-和run-区别"><a href="#start-和run-区别" class="header-anchor">#</a> start()和run()区别</h2> <ul><li>每个线程都是通过某个特定Thread对象所对应的方法来完成其操作，run()方法称为线程体</li> <li>通过调用start()方法来启动一个线程，start()方法用于启动线程，run()方法用于执行线程的运行时代码</li> <li>run()方法可以重复调用，start()方法只能调用一次</li> <li>调用start()方法无需等待run()方法体代码执行完毕就可以继续执行其他的代码，此时线程是处于就绪状态，并没有运行，然后通过Thread类调用run()方法来完成其运行状态</li> <li>run()方法运行结束，线程终止，然后CPU再调度其它线程</li> <li>run()方法是在本线程里的，只是线程中的一个函数，而不是多线程的，如果直接调用run()方法，相当于调用一个普通函数，直接调用run()方法必须等待run()方法执行完毕才能执行下一次run()方法的调用，所以执行路径仍然是一条，根本没有线程的特征</li> <li>调用start()方法执行run()方法，new一个Thread时，线程进入新建状态，调用start()方法，启动一个线程并使线程进入就绪状态，当分配到时间片后就开始进入运行状态，start()方法会执行线程的相应准备工作，然后自动调用run()方法的内容</li> <li>直接调用run()方法，会把run()方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它</li></ul> <h2 id="callable和future"><a href="#callable和future" class="header-anchor">#</a> Callable和Future</h2> <ul><li>Callable类似Runnable，Runnable不能返回结果，并且无法抛出返回结果异常，Callable可以返回值</li> <li>Future可以拿到异步执行任务的返回值，可能是一个还没有完成的异步任务的结果</li> <li>Callable用于产生结果，Future用于获取结果</li></ul> <h2 id="futuretask"><a href="#futuretask" class="header-anchor">#</a> FutureTask</h2> <ul><li>一个异步运算的任务</li> <li>可以对这个异步运算的任务的结果进行等待获取、判断是否完成、取消任务等操作</li> <li>FutureTask是Runnable接口的实现类，所以也可以放入线程池中</li></ul> <h2 id="线程状态"><a href="#线程状态" class="header-anchor">#</a> 线程状态</h2> <ul><li>新建：新创建一个线程对象</li> <li>可运行（runnable）：线程对象创建后，当调用线程对象start()方法时</li> <li>运行（running）:可运行状态获取到cpu的时间片</li> <li>阻塞（block）:处于运行状态的线程由于某种原因，暂时放弃对cpu的使用，停止执行，进入阻塞状态，直到其进入到就绪状态，才有机会再次被cpu调用进入运行状态
<ul><li>等待阻塞：运行状态中的线程执行wait()方法，Jvm会把该线程放入等待队列（waitting queue)中，让本线程进入到等待阻塞状态</li> <li>同步阻塞：线程在获取synchronized同步锁失败（因为锁被其他线程所占用），则jvm会把该线程放入锁池（lock pool）中，线程会进入同步阻塞状态</li> <li>其他阻塞：通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入阻塞状态，当sleep()状态超时时，join()等待线程终止或者超时、或者I/O处理完毕时，线程重新进入就绪状态</li></ul></li> <li>死亡（dead）：线程run()、main()方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期，死亡线程不可复生</li></ul> <h2 id="线程调度算法"><a href="#线程调度算法" class="header-anchor">#</a> 线程调度算法</h2> <ul><li>分时调度算法：所有线程轮流获得cpu使用权，平均分配每个线程占用的cpu时间片</li> <li>抢占式调度算法：优先让可运行池中优先级高的线程占用cpu，如果可运行池中线程优先级相同，那么久随机选择一个线程让其占用cpu，处于运行状态的线程会一直运行，直至它不得不放弃cpu</li></ul> <h2 id="终止线程运行"><a href="#终止线程运行" class="header-anchor">#</a> 终止线程运行</h2> <ul><li>线程体调用了yield方法让出了对cpu的占用权利</li> <li>线程体中调用了sleep方法使线程进入睡眠状态</li> <li>线程由于IO操作受阻</li> <li>另外一个更高优先级线程出现</li> <li>在支持时间片的系统中，该线程的时间片用完</li></ul> <h2 id="线程调度器和时间分片"><a href="#线程调度器和时间分片" class="header-anchor">#</a> 线程调度器和时间分片</h2> <ul><li>前者（Thread Scheduler）是一个操作系统服务，负责为Runnable状态的线程分配cpu时间，一旦创建一个线程并启动它，它的执行并依赖于线程调度器的实现</li> <li>后者（Time Slicing）是将可用的CPU时间分配给可用的Runnable线程的过程，分配CPU时间可以基于线程优先级或者线程等待时间</li> <li>前者不受到JVM控制</li></ul> <h2 id="线程同步和线程调度相关方法"><a href="#线程同步和线程调度相关方法" class="header-anchor">#</a> 线程同步和线程调度相关方法</h2> <ul><li>wait()：使一个线程处于等待(阻塞)状态，并且释放所持有的对象锁</li> <li>sleep()：使一个正在运行的线程处于睡眠状态</li> <li>notify()：唤醒一个处于等待状态的线程，在调用次方法的时候，并不能确切的唤醒某一个等待状态的线程，而是有jvm确定唤醒哪个线程，且与优先级无关</li> <li>notityAll()：唤醒所有处于等待状态的线程，并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态</li></ul> <h2 id="sleep-和wait-区别"><a href="#sleep-和wait-区别" class="header-anchor">#</a> sleep()和wait()区别</h2> <ul><li>前者是Thread线程类的静态方法，后者是object类的方法</li> <li>前者不释放锁，后者释放锁</li> <li>前者用于暂停执行，后者用于线程间交互通信</li> <li>前者执行后，线程会自动苏醒，后者执行后，不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法</li></ul> <h2 id="线程通信wait-、notify-、notifyall-放在object原因"><a href="#线程通信wait-、notify-、notifyall-放在object原因" class="header-anchor">#</a> 线程通信wait()、notify()、notifyAll()放在object原因</h2> <blockquote><p>一个线程可以持有多把锁，当要放弃锁时，管理状态更加复杂，所以要定义在object类中</p></blockquote> <h2 id="wait-、notify-、notifyall-必须在同步方法或者同步块中原因"><a href="#wait-、notify-、notifyall-必须在同步方法或者同步块中原因" class="header-anchor">#</a> wait()、notify()、notifyAll()必须在同步方法或者同步块中原因</h2> <blockquote><p>由于所有的这些方法都需要线程持有对象的锁，所以只能通过同步来实现，所以只能在同步方法或者同步块中被调用</p></blockquote> <h2 id="thread中yield-作用"><a href="#thread中yield-作用" class="header-anchor">#</a> Thread中yield()作用</h2> <blockquote><p>使当前线程从执行状态（运行状态）变为可执行态（就绪状态)</p></blockquote> <h2 id="thread中sleep-方法和yield-方法是静态原因"><a href="#thread中sleep-方法和yield-方法是静态原因" class="header-anchor">#</a> Thread中sleep()方法和yield()方法是静态原因</h2> <blockquote><p>sleep()和yield()方法只能作用在正在执行的线程上运行</p></blockquote> <h2 id="sleep-和yield-方法区别"><a href="#sleep-和yield-方法区别" class="header-anchor">#</a> sleep()和yield()方法区别</h2> <ul><li>前者给其他线程运行机会时不考虑线程优先级；后者只会给相同优先级或更高优先级的线程运行机会</li> <li>前者执行后转入阻塞状态；后者执行转入就绪状态</li> <li>前者声明抛出InterruptedException；后者没有声明任何异常</li> <li>前者比后者具有更好的可移植性，</li></ul> <h2 id="停止一个正在运行的线程方法"><a href="#停止一个正在运行的线程方法" class="header-anchor">#</a> 停止一个正在运行的线程方法</h2> <ul><li>使用退出标志，使线程正常退出，就是当run方法完成后线程终止</li> <li>使用stop方法强行终止，但不推荐这种方式</li> <li>使用interrupt方法中断线程</li></ul> <h2 id="interrupt和isinterrupted方法的区别"><a href="#interrupt和isinterrupted方法的区别" class="header-anchor">#</a> interrupt和isInterrupted方法的区别</h2> <ul><li>前者用于中断线程；后者查看当前中断信号是true还是false</li></ul> <h2 id="notify和notifyall区别"><a href="#notify和notifyall区别" class="header-anchor">#</a> notify和notifyAll区别</h2> <ul><li>前者只会唤醒一个线程；后者会唤醒所有的线程</li> <li>前者调用后只会唤醒一个线程，具体唤醒哪一个由虚拟机控制；后者执行后会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，不成功则留在锁池等待锁被释放后再次参与竞争</li></ul> <h2 id="线程通信协作方式"><a href="#线程通信协作方式" class="header-anchor">#</a> 线程通信协作方式</h2> <ul><li>syncrhoized加锁的线程的Object类的wait、notify、notifyAll方法</li> <li>ReentrantLock类加锁的线程的Condition类的await、signal、signalAll方法</li></ul> <h2 id="线程间直接的数据交换方法"><a href="#线程间直接的数据交换方法" class="header-anchor">#</a> 线程间直接的数据交换方法</h2> <ul><li>通过管道进行线程间通信</li> <li>字节流</li> <li>字符流</li></ul> <h2 id="同步块和同步方法比较"><a href="#同步块和同步方法比较" class="header-anchor">#</a> 同步块和同步方法比较</h2> <blockquote><p>同步块是更好的选择，因为它不会锁住整个对象；同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致它们停止执行并需要等待获得这个对象上的锁。</p> <p>同步块更符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，从侧面来说也可以避免死锁</p> <p>一条原则：同步的范围越小越好</p></blockquote> <h2 id="线程同步和线程互斥"><a href="#线程同步和线程互斥" class="header-anchor">#</a> 线程同步和线程互斥</h2> <ul><li>线程同步：当一个线程对共享的数据进行操作时，应该使之成为一个原子操作，即在没有完成相关操作之前，不允许其他线程打断它
<ul><li>用户模式：只在用户态完成操作
<ul><li>原子操作、临界区</li></ul></li> <li>内核模式：利用系统内核对象的单一性来进行同步使用时需要切换内核态与用户态
<ul><li>事件、信号量、互斥量</li></ul></li></ul></li> <li>线程互斥：对于共享的进程系统资源，在各单个线程访问时的排他性。当有诺干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其他要使用该资源的线程必须等待，直到占用资源者释放该资源，线程互斥可以看成是一种特殊的线程同步</li></ul> <h2 id="监视器-monitor-内部做线程同步方法"><a href="#监视器-monitor-内部做线程同步方法" class="header-anchor">#</a> 监视器（Monitor)内部做线程同步方法</h2> <ul><li>在java虚拟机中，每个对象（Object和class）通过某种逻辑关联监视器，每个监视器和一个对象引用相关联，为了实现监视器的互斥功能，每个对象都关联着一把锁，一旦方法被synchronized修饰，那么这部分就放入了监视器的监视区域，确保一次只有一个线程执行该部分代码，线程在获取锁之前不允许执行该部分的代码</li> <li>java提供显示监视器（Lock） 和隐士监视器（synchronized）两种锁方案</li></ul> <h2 id="保证多线程运行安全方法"><a href="#保证多线程运行安全方法" class="header-anchor">#</a> 保证多线程运行安全方法</h2> <ul><li>使用安全类、如java.util.concurrent下的类，使用原子类Atomiclnteger</li> <li>使用自动锁synchronized</li> <li>使用手动锁Lock</li></ul> <h2 id="线程优先级"><a href="#线程优先级" class="header-anchor">#</a> 线程优先级</h2> <ul><li>是一个int变量（从1-10），1代表低优先级，10代表高优先级</li></ul> <h2 id="线程类的构造方法、静态块是被哪个线程调用"><a href="#线程类的构造方法、静态块是被哪个线程调用" class="header-anchor">#</a> 线程类的构造方法、静态块是被哪个线程调用</h2> <ul><li>线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，run方法中代码才是被线程自身所调用的。</li></ul> <h2 id="获取一份线程dump文件方法"><a href="#获取一份线程dump文件方法" class="header-anchor">#</a> 获取一份线程dump文件方法</h2> <ul><li>linux下通过命令 kill -3 PID（进程的进程ID）</li> <li>Windows下通过Ctrl+Break来获取</li></ul> <h2 id="new-对象执行步骤"><a href="#new-对象执行步骤" class="header-anchor">#</a> new   对象执行步骤</h2> <ul><li>1.为对象分配内存空间</li> <li>2.初始化对象</li> <li>3.将对象指向分配的内存地址</li> <li>指令重排序问题
<ul><li>由于JVM指令重排的特性，new一个对象的执行顺序可能会乱序，乱序在单线程下不会出现问题，但是在多线程下会导致一个线程获取还没有初始化的实例；例如线程T1执行了1和3，此时线程T2获取发现对象不为空，所以返回该对象，但是该对象此时还没有初始化；使用volatile可以禁止指令的重排序，保证多线程下也能正常运行</li></ul></li></ul> <h2 id="synchronized"><a href="#synchronized" class="header-anchor">#</a> synchronized</h2> <ul><li>可重入原理：一个线程获取到该锁之后，该线程可以继续获得该锁，底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表示该锁未被任何线程持有</li> <li>锁升级原理： 在锁对象的对象头里面有一个threadid字段，第一次访问的时候该字段为空，jvm让其持有偏向锁，并将该字段设置为其线程id，再次进入会先判断该字段是否与其线程id一致，不一致，则升级偏向锁为轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数后，如果还没有获取到锁，此时就会把锁从轻量级升级为重量级锁，此过程为锁升级；目的是为了减低锁带来的性能消耗</li> <li>当一个线程进入一个对象的synchronized方法A后，其他线程不能进入该对象的synchronized方法B，因为synchronized修饰符要求执行方法时要获得对象的锁，所以进入方法A时就把该对象的锁取走，方法B只能等锁释放再次获取</li></ul> <h2 id="synchronized、volatile、cas"><a href="#synchronized、volatile、cas" class="header-anchor">#</a> synchronized、volatile、cas</h2> <ul><li>synchronized是悲观锁，属于抢占式，会引起其他线程阻塞</li> <li>volatile提供多线程共享变量可见性和禁止指令重排序优化</li> <li>CAS是基于冲突检测的乐观锁（非阻塞）</li></ul> <h2 id="synchronized和lock区别"><a href="#synchronized和lock区别" class="header-anchor">#</a> synchronized和lock区别</h2> <ul><li>前者是内置关键字，属于jvm层面；后者是一个java类</li> <li>前者可以给类、方法、代码块加锁；后者只能给代码块加锁</li> <li>前者不需要手动获取锁和释放锁，使用简单，发生异常自动释放锁，不会造成死锁；后者需要自己加锁和释放锁，如使用不当没有及时释放就会造成死锁</li> <li>后者可以知道有没有成功获取锁，前者无法办到</li></ul> <h2 id="synchronized-和reentrantlock区别"><a href="#synchronized-和reentrantlock区别" class="header-anchor">#</a> synchronized 和ReentrantLock区别</h2> <ul><li>前者是关键字；后者是类，可以被继承、可以有方法</li> <li>相同点：两者都是可重入锁</li></ul> <h2 id="volatile"><a href="#volatile" class="header-anchor">#</a> volatile</h2> <ul><li>保证线程之间可见性：确保一个线程的修改能对其他线程是可见的，当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，会去内存中读取新值</li> <li>禁止指令重排序</li> <li>可以创建volatile类型数组，不过只能一个指向数组的引用，而不是整个数组。意思是，如果改变引用指向的数组，将会受到volatile的保护，但是如果多个线程同时改变数组的元素，volatile标识符就不能起到之前的保护作用了</li> <li>无法保证原子性，但是可以保证long和double的原子性</li></ul> <h2 id="final-2"><a href="#final-2" class="header-anchor">#</a> final</h2> <ul><li>不可变对象即对象一旦被创建，它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象</li> <li>不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码的执行效率</li></ul> <h2 id="lock"><a href="#lock" class="header-anchor">#</a> lock</h2> <ul><li>可以使锁更公平</li> <li>可以使线程在等待锁的时候响应中断</li> <li>可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</li> <li>可以在不同的范围以不同的顺序获取和释放锁</li> <li>lock是synchronized的扩展板，lock提供了无条件的、可轮询的（trylock方法)、定时的（trylock带参方法）、可中断的（lockInterruptibly方法）、可多条件队列的（newCondition方法）锁操作，另外lock的实现类基本都支持非公平锁（默认）和公平锁，synchronized只支持非公平锁，当然，大部分情况下，非公平锁是高效的选择</li></ul> <h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="header-anchor">#</a> 乐观锁和悲观锁</h2> <ul><li>悲观锁：总是假设坏的情况，每次去拿数据时都认为被人会修改，所以每次在拿数据时都会上锁，synchronized关键字的实现就是悲观锁</li> <li>乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。该锁适用于多读的应用类型</li></ul> <h2 id="cas"><a href="#cas" class="header-anchor">#</a> CAS</h2> <ul><li>compare and swap 比较交换</li> <li>一种基于锁的操作，是乐观锁</li> <li>包含三个操作数---内存位置（V） 、预期原值（A）和新值（B),如果内存地址里面的值和A的值是一样的，那么久将内存里面的值更新成B</li> <li>通过无线循环来获取数据，如果第一轮循环中，a线程获取地址里面的值被b线程修改，那么a线程需要自旋，到下次循环才有可能机会执行</li> <li>问题
<ul><li>ABA问题：一个线程从内存位置V中取出A，这时候另一个线程也从内存中取出A，并且其中一个线程进行了一些操作把A变成B，然后又将V位置的数据变为A，这时候另一个线程进行cas操作时发现内存中仍然是A，所以操作成功，这里存在潜藏的问题，从java1.5开始提供一个类 AtomicStampedReference来解决</li> <li>循环时间长开销大：对于资源竞争严重（线程冲突严重）的情况，cas自旋的概率会比较大，从而浪费更多的cpu资源，效率低于synchronized</li> <li>只能保证一个共享变量的原子操作：当对一个共享变量执行操作时，可以使用循环cas的方式来保证原子操作，但是对多个共享变量操作时，循环cas就无法保证操作的原子性，这个时候只能用锁</li></ul></li></ul> <h2 id="活锁和饥饿"><a href="#活锁和饥饿" class="header-anchor">#</a> 活锁和饥饿</h2> <ul><li>活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败；与死锁的区别在于处于活锁的实体是在不断的改变状态，而处于死锁的实体表现为等待；活锁有可能自行解开，死锁不能</li> <li>饥饿：一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态；导致线程饥饿的原因:高优先级线程吞噬所有的低优先级线程的cpu时间；线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续的对该同步块进行访问；线程在等待一个本身也处于永久等待完成的对象（比如调用这个对象的wait方法），因为其他线程总是被持续的获得唤醒</li></ul> <h2 id="aqs"><a href="#aqs" class="header-anchor">#</a> AQS</h2> <ul><li>全称为AbstractQueueSynchronize</li> <li>维护一个volatile int state字段和一个双向线程等待队列</li> <li>它的执行过程是：当线程A拿到state字段的值为0时，把state的值修改为1，然后执行自身任务，当此时有线程跟A争抢资源时，同样还是先获取state字段的值，如果为1，则从队尾进入队列，且线程状态修改为阻塞状态</li></ul> <h2 id="readwritelock"><a href="#readwritelock" class="header-anchor">#</a> ReadWriteLock</h2> <ul><li>是一个读写接口</li> <li>读写锁用来提升并发程序性能的锁分离技术</li> <li>ReentrantReadWriteLock是ReadWriteLock的一个具体实现，实现了读写分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</li> <li>特性
<ul><li>公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平</li> <li>重进入：读锁和写锁都支持线程重进入</li> <li>锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能降级为读锁</li></ul></li></ul> <h2 id="concurrenthashmap"><a href="#concurrenthashmap" class="header-anchor">#</a> ConcurrentHashMap</h2> <ul><li>把实际map划分成若干部分来实现它的可扩展性和线程安全，这种划分是使用并发度获得的，它是构造函数的一个可选参数，默认为16，这样在多线程情况下就能避免争用</li> <li>jdk8后，摒弃Segment（锁段）概念，启用CAS算法，同时加入更多的辅助变量来提高并发度</li></ul> <h2 id="并发容器实现"><a href="#并发容器实现" class="header-anchor">#</a> 并发容器实现</h2> <ul><li>采用分段锁机制，允许任意数量的读线程并发的访问容器，并且执行读操作的线程和写操作的线程也可以并发的访问容器，同时也允许一定数量的写操作线程并发地修改容器</li> <li>分段锁：把容器内部分为小段，每段分别加锁管理，实现更高的吞吐量</li></ul> <h2 id="synchronizedmap和concurrenthashmap区别"><a href="#synchronizedmap和concurrenthashmap区别" class="header-anchor">#</a> synchronizedMap和ConcurrentHashMap区别</h2> <ul><li>前者一次锁住整张表来保证线程安全，每次只能有一个线程访问，后者使用分段锁来保证线程安全，一次锁住一个，默认将hash表分为16段</li></ul> <h2 id="copyonwritearraylist"><a href="#copyonwritearraylist" class="header-anchor">#</a> CopyOnWriteArrayList</h2> <ul><li>是一个并发容器</li> <li>在非复合场景下是线程安全的</li> <li>免锁容器</li> <li>缺点
<ul><li>写操作触发拷贝数组，消耗内存，数据较多时可能会导致young gc或者full gc</li> <li>不能用于实时读场景，它只能做到最终一致性</li></ul></li></ul> <h2 id="threadlocal"><a href="#threadlocal" class="header-anchor">#</a> ThreadLocal</h2> <ul><li>线程局部变量，属于线程自身所有，不在多个线程间共享</li> <li>内存泄漏：ThreadLocalMap中使用的key为Threadlocal的弱引用，而value是强引用，所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key会清理掉，而value不会被清理掉，这样一来，ThreadLocalMap中就会出现key为null的Entry，如果不做任何措施，value永远不会被GC回收，就可能会产生内存泄漏，ThreadLocalMap实现中已经考虑了这种情况，所以在调用set()、get()、remove()方法时，会清理掉key为null的记录；解决方案就是每次使用完ThreadLocal，都调用它的remove方法清除数据</li></ul> <h2 id="阻塞队列"><a href="#阻塞队列" class="header-anchor">#</a> 阻塞队列</h2> <ul><li>在队列为空时，获取元素的线程会等待队列变为非空；当队列满时，存储元素的线程会等待队列可用</li> <li>ArrayBlockingQueue:一个由数组结构组成的有界阻塞队列</li> <li>LinkedBlockingQueue：一个由链表结构组成的有界队列</li> <li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li> <li>DelayQueue:一个使用优先级队列实现的无界阻塞队列</li> <li>SynchronousQueue：一个不存储元素的阻塞队列</li> <li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li> <li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul> <h2 id="线程池"><a href="#线程池" class="header-anchor">#</a> 线程池</h2> <ul><li>使用Executors类提供的一些静态方法创建
<ul><li>newSingleThreadExecutor方法：创建一个单线程的线程池，这个线程池只有一个线程在工作，也就相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保证所有任务的执行顺序按照任务的提交顺序执行</li> <li>newFixedThreadPool方法：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的大小，线程池大小一旦达到最大值就会保持不变，如果某个线程因为异常而结束，那么线程会补充一个新线程，如果希望在服务器上使用线程池，建议使用该线程池</li> <li>newCachedThreadPool方法：创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需要的的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加先线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者jvm）能够创建的最大线程大小</li> <li>newScheduledThreadPool方法：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求</li></ul></li> <li>优点
<ul><li>降低资源消耗：重用存在的线程，减少对象创建销毁的开销</li> <li>提高响应速度：可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多的资源竞争，避免堵塞，当任务到达时，任务可以不需要等到线程创建就能立即执行</li> <li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li> <li>附加功能：提供定时执行、定期执行、单线程、并发数控制等功能</li></ul></li> <li>状态
<ul><li>Running：正常状态，接受新的任务，处理等待队列中的任务</li> <li>ShutDown：不接受新的任务，但是会继续处理等待队列中的任务</li> <li>Stop：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行的任务线程</li> <li>Tidying：所有的任务都销毁了，workCount为0，线程池的状态在转换为该状态时，会执行钩子方法terminated()</li> <li>TerminaTed：terminated方法结束后，线程池的状态就会变为此状态</li></ul></li> <li>submit方法：可以执行Runnable和Callable类型的任务，且可以返回持有计算结果的Future对象，方便Exception处理</li> <li>execute方法：只能执行Runnable类型的任务，没有异常处理，不能返回值</li> <li>使用ThreadPoolExecutor可以创建自定义线程池</li></ul> <h2 id="线程组"><a href="#线程组" class="header-anchor">#</a> 线程组</h2> <ul><li>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构优点类似于树的形式</li> <li>线程组和线程池是两个不同的概念，它们的作用完全不同，前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销</li> <li>不推荐使用线程组的原因是因为有很多安全隐患</li></ul> <h2 id="threadpoolexecutor"><a href="#threadpoolexecutor" class="header-anchor">#</a> ThreadPoolExecutor</h2> <ul><li>corePoolSize参数：核心线程数，线程数定义了大小可以同时运行的线程数量</li> <li>maximunPoolSize：线程池中允许存在的工作线程的最大数量</li> <li>workQueue参数：当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到，任务就会被存放在队列中</li> <li>keepAliveTime参数：线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是等待，知道等待的时间超过了该参数值才会被回收销毁</li> <li>unit参数：keepAliveTime参数的时间单位</li> <li>threadFactory参数：为线程池提供创建新线程的线程工厂</li> <li>handler参数：线程池任务队列超过maxinumPoolSize之后的拒绝策略</li></ul> <h2 id="并发工具类countdownlatch和cyclibarriar的区别"><a href="#并发工具类countdownlatch和cyclibarriar的区别" class="header-anchor">#</a> 并发工具类CountDownLatch和CycliBarriar的区别</h2> <ul><li>前者一般用于某个线程等待若干个其他线程执行完任务之后它才执行；后者一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</li> <li>前者强调一个线程等待多个线程完成某件事情；后者是多个线程互等，等大家都完成，再携手共进</li> <li>调用前者的countDown方法后，当前线程并不会阻塞，会继续往下执行；调用后者的await方法，会阻塞当前线程，直到后者指定的线程全部都达到了指定点，才能继续往下执行</li> <li>前者方法较少，操作比较简单；后者提供的方法多，能够通过getNumberWaiting、isBroken这些方法获取当前多个线程的状态，并且后者的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能</li> <li>前者不能复用，后者可以复用</li></ul> <h2 id="常用并发工具类"><a href="#常用并发工具类" class="header-anchor">#</a> 常用并发工具类</h2> <ul><li>Semaphore（信号量）：允许多个线程同时访问，可以指定多个线程同时访问某个资源</li> <li>CountDownLatch(倒计时器)：是一个同步工具类，用来协调多个线程之间的同步。通常用来控制线程等待，可以让某一个线程等待直到倒计时结束，再开始执行</li> <li>CyclicBarrier（循环栅栏）：和CountDownLatch非常类似，但是功能比其更加复杂和强大。它可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，默认的构造函数是（int parties),其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier已经到达了屏障，然后当前线程被阻塞</li></ul></div></section> <footer class="page-edit"><!----> <!----></footer> <!----> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#int和integer区别" class="sidebar-link reco-side-int和integer区别" data-v-b57cc07c>int和Integer区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#类型详解" class="sidebar-link reco-side-类型详解" data-v-b57cc07c>类型详解</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#修饰符访问权限" class="sidebar-link reco-side-修饰符访问权限" data-v-b57cc07c>修饰符访问权限</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#jvm、jre和jdk的关系" class="sidebar-link reco-side-jvm、jre和jdk的关系" data-v-b57cc07c>JVM、JRE和JDK的关系</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#java字节码文件" class="sidebar-link reco-side-java字节码文件" data-v-b57cc07c>Java字节码文件</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#java和c-的区别" class="sidebar-link reco-side-java和c-的区别" data-v-b57cc07c>Java和C++的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#oracle-jdk和open-jdk对比" class="sidebar-link reco-side-oracle-jdk和open-jdk对比" data-v-b57cc07c>oracle jdk和open jdk对比</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#java数据类型" class="sidebar-link reco-side-java数据类型" data-v-b57cc07c>java数据类型</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#switch作用类型" class="sidebar-link reco-side-switch作用类型" data-v-b57cc07c>switch作用类型</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#四舍五入原理" class="sidebar-link reco-side-四舍五入原理" data-v-b57cc07c>四舍五入原理</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#java语言采用的编码方案" class="sidebar-link reco-side-java语言采用的编码方案" data-v-b57cc07c>Java语言采用的编码方案</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#注释" class="sidebar-link reco-side-注释" data-v-b57cc07c>注释</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#final" class="sidebar-link reco-side-final" data-v-b57cc07c>final</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#final-finally-finalize区别" class="sidebar-link reco-side-final-finally-finalize区别" data-v-b57cc07c>final finally finalize区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#this关键字" class="sidebar-link reco-side-this关键字" data-v-b57cc07c>this关键字</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#super" class="sidebar-link reco-side-super" data-v-b57cc07c>super</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#this和super的区别" class="sidebar-link reco-side-this和super的区别" data-v-b57cc07c>this和super的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#static" class="sidebar-link reco-side-static" data-v-b57cc07c>static</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#break、continue、return" class="sidebar-link reco-side-break、continue、return" data-v-b57cc07c>break、continue、return</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#跳出当前多重循环嵌套" class="sidebar-link reco-side-跳出当前多重循环嵌套" data-v-b57cc07c>跳出当前多重循环嵌套</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#抽象" class="sidebar-link reco-side-抽象" data-v-b57cc07c>抽象</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#封装" class="sidebar-link reco-side-封装" data-v-b57cc07c>封装</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#继承" class="sidebar-link reco-side-继承" data-v-b57cc07c>继承</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#多态" class="sidebar-link reco-side-多态" data-v-b57cc07c>多态</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#五大基本原则" class="sidebar-link reco-side-五大基本原则" data-v-b57cc07c>五大基本原则</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#抽象类和接口" class="sidebar-link reco-side-抽象类和接口" data-v-b57cc07c>抽象类和接口</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#实例和引用区别" class="sidebar-link reco-side-实例和引用区别" data-v-b57cc07c>实例和引用区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#内部类" class="sidebar-link reco-side-内部类" data-v-b57cc07c>内部类</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#和equals的区别" class="sidebar-link reco-side-和equals的区别" data-v-b57cc07c>==和equals的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#string类型" class="sidebar-link reco-side-string类型" data-v-b57cc07c>String类型</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashcode与equals" class="sidebar-link reco-side-hashcode与equals" data-v-b57cc07c>hashCode与equals</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#值传递" class="sidebar-link reco-side-值传递" data-v-b57cc07c>值传递</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#java包" class="sidebar-link reco-side-java包" data-v-b57cc07c>java包</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#bio、nio、aio" class="sidebar-link reco-side-bio、nio、aio" data-v-b57cc07c>BIO、NIO、AIO</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#files的常用方法" class="sidebar-link reco-side-files的常用方法" data-v-b57cc07c>Files的常用方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#反射" class="sidebar-link reco-side-反射" data-v-b57cc07c>反射</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#数组没有length-有length属性-string有length" class="sidebar-link reco-side-数组没有length-有length属性-string有length" data-v-b57cc07c>数组没有length(),有length属性，String有length()</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#string-类常用方法" class="sidebar-link reco-side-string-类常用方法" data-v-b57cc07c>String 类常用方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashmap使用string做key好处" class="sidebar-link reco-side-hashmap使用string做key好处" data-v-b57cc07c>HashMap使用string做key好处</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#string、stringbuffer、stringbuilder" class="sidebar-link reco-side-string、stringbuffer、stringbuilder" data-v-b57cc07c>String、StringBuffer、StringBuilder</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#集合" class="sidebar-link reco-side-集合" data-v-b57cc07c>集合</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程安全集合" class="sidebar-link reco-side-线程安全集合" data-v-b57cc07c>线程安全集合</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#快速故障-fail-fast" class="sidebar-link reco-side-快速故障-fail-fast" data-v-b57cc07c>快速故障（fail-fast)</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#确保一个集合不能被修改" class="sidebar-link reco-side-确保一个集合不能被修改" data-v-b57cc07c>确保一个集合不能被修改</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#迭代器-iterator" class="sidebar-link reco-side-迭代器-iterator" data-v-b57cc07c>迭代器 Iterator</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#arraylist和linklist" class="sidebar-link reco-side-arraylist和linklist" data-v-b57cc07c>ArrayList和LinkList</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#vector" class="sidebar-link reco-side-vector" data-v-b57cc07c>Vector</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#transient" class="sidebar-link reco-side-transient" data-v-b57cc07c>transient</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#list和set区别" class="sidebar-link reco-side-list和set区别" data-v-b57cc07c>List和Set区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashset查重" class="sidebar-link reco-side-hashset查重" data-v-b57cc07c>HashSet查重</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashcode和equals规则" class="sidebar-link reco-side-hashcode和equals规则" data-v-b57cc07c>hashcode和equals规则</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashset和hashmap区别" class="sidebar-link reco-side-hashset和hashmap区别" data-v-b57cc07c>HashSet和HashMap区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashmap实现原理" class="sidebar-link reco-side-hashmap实现原理" data-v-b57cc07c>HashMap实现原理</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#hashmap和hashtable" class="sidebar-link reco-side-hashmap和hashtable" data-v-b57cc07c>HashMap和HashTable</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#throwable" class="sidebar-link reco-side-throwable" data-v-b57cc07c>Throwable</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#error-错误" class="sidebar-link reco-side-error-错误" data-v-b57cc07c>Error（错误）</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#exception-异常" class="sidebar-link reco-side-exception-异常" data-v-b57cc07c>Exception（异常）</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#受检异常和非受检异常" class="sidebar-link reco-side-受检异常和非受检异常" data-v-b57cc07c>受检异常和非受检异常</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#异常处理关键字" class="sidebar-link reco-side-异常处理关键字" data-v-b57cc07c>异常处理关键字</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#自定义异常" class="sidebar-link reco-side-自定义异常" data-v-b57cc07c>自定义异常</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#try-with-resource" class="sidebar-link reco-side-try-with-resource" data-v-b57cc07c>try-with-resource</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#jvm处理异常过程" class="sidebar-link reco-side-jvm处理异常过程" data-v-b57cc07c>JVM处理异常过程</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#final、finally、finalize区别" class="sidebar-link reco-side-final、finally、finalize区别" data-v-b57cc07c>final、finally、finalize区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#try-catch-finally中哪部分可省略" class="sidebar-link reco-side-try-catch-finally中哪部分可省略" data-v-b57cc07c>try-catch-finally中哪部分可省略</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#常见runtimeexception异常" class="sidebar-link reco-side-常见runtimeexception异常" data-v-b57cc07c>常见RuntimeException异常</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#异常处理最佳实践" class="sidebar-link reco-side-异常处理最佳实践" data-v-b57cc07c>异常处理最佳实践</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#并发三要素" class="sidebar-link reco-side-并发三要素" data-v-b57cc07c>并发三要素</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程安全问题原因" class="sidebar-link reco-side-线程安全问题原因" data-v-b57cc07c>线程安全问题原因</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#并行和并发" class="sidebar-link reco-side-并行和并发" data-v-b57cc07c>并行和并发</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#多线程" class="sidebar-link reco-side-多线程" data-v-b57cc07c>多线程</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程和进程" class="sidebar-link reco-side-线程和进程" data-v-b57cc07c>线程和进程</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#上下文切换" class="sidebar-link reco-side-上下文切换" data-v-b57cc07c>上下文切换</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#守护线程和用户线程" class="sidebar-link reco-side-守护线程和用户线程" data-v-b57cc07c>守护线程和用户线程</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#linux查找cpu利用率最高的线程" class="sidebar-link reco-side-linux查找cpu利用率最高的线程" data-v-b57cc07c>linux查找cpu利用率最高的线程</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程死锁" class="sidebar-link reco-side-线程死锁" data-v-b57cc07c>线程死锁</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#创建线程方法" class="sidebar-link reco-side-创建线程方法" data-v-b57cc07c>创建线程方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#start-和run-区别" class="sidebar-link reco-side-start-和run-区别" data-v-b57cc07c>start()和run()区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#callable和future" class="sidebar-link reco-side-callable和future" data-v-b57cc07c>Callable和Future</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#futuretask" class="sidebar-link reco-side-futuretask" data-v-b57cc07c>FutureTask</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程状态" class="sidebar-link reco-side-线程状态" data-v-b57cc07c>线程状态</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程调度算法" class="sidebar-link reco-side-线程调度算法" data-v-b57cc07c>线程调度算法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#终止线程运行" class="sidebar-link reco-side-终止线程运行" data-v-b57cc07c>终止线程运行</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程调度器和时间分片" class="sidebar-link reco-side-线程调度器和时间分片" data-v-b57cc07c>线程调度器和时间分片</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程同步和线程调度相关方法" class="sidebar-link reco-side-线程同步和线程调度相关方法" data-v-b57cc07c>线程同步和线程调度相关方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#sleep-和wait-区别" class="sidebar-link reco-side-sleep-和wait-区别" data-v-b57cc07c>sleep()和wait()区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程通信wait-、notify-、notifyall-放在object原因" class="sidebar-link reco-side-线程通信wait-、notify-、notifyall-放在object原因" data-v-b57cc07c>线程通信wait()、notify()、notifyAll()放在object原因</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#wait-、notify-、notifyall-必须在同步方法或者同步块中原因" class="sidebar-link reco-side-wait-、notify-、notifyall-必须在同步方法或者同步块中原因" data-v-b57cc07c>wait()、notify()、notifyAll()必须在同步方法或者同步块中原因</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#thread中yield-作用" class="sidebar-link reco-side-thread中yield-作用" data-v-b57cc07c>Thread中yield()作用</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#thread中sleep-方法和yield-方法是静态原因" class="sidebar-link reco-side-thread中sleep-方法和yield-方法是静态原因" data-v-b57cc07c>Thread中sleep()方法和yield()方法是静态原因</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#sleep-和yield-方法区别" class="sidebar-link reco-side-sleep-和yield-方法区别" data-v-b57cc07c>sleep()和yield()方法区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#停止一个正在运行的线程方法" class="sidebar-link reco-side-停止一个正在运行的线程方法" data-v-b57cc07c>停止一个正在运行的线程方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#interrupt和isinterrupted方法的区别" class="sidebar-link reco-side-interrupt和isinterrupted方法的区别" data-v-b57cc07c>interrupt和isInterrupted方法的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#notify和notifyall区别" class="sidebar-link reco-side-notify和notifyall区别" data-v-b57cc07c>notify和notifyAll区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程通信协作方式" class="sidebar-link reco-side-线程通信协作方式" data-v-b57cc07c>线程通信协作方式</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程间直接的数据交换方法" class="sidebar-link reco-side-线程间直接的数据交换方法" data-v-b57cc07c>线程间直接的数据交换方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#同步块和同步方法比较" class="sidebar-link reco-side-同步块和同步方法比较" data-v-b57cc07c>同步块和同步方法比较</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程同步和线程互斥" class="sidebar-link reco-side-线程同步和线程互斥" data-v-b57cc07c>线程同步和线程互斥</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#监视器-monitor-内部做线程同步方法" class="sidebar-link reco-side-监视器-monitor-内部做线程同步方法" data-v-b57cc07c>监视器（Monitor)内部做线程同步方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#保证多线程运行安全方法" class="sidebar-link reco-side-保证多线程运行安全方法" data-v-b57cc07c>保证多线程运行安全方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程优先级" class="sidebar-link reco-side-线程优先级" data-v-b57cc07c>线程优先级</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程类的构造方法、静态块是被哪个线程调用" class="sidebar-link reco-side-线程类的构造方法、静态块是被哪个线程调用" data-v-b57cc07c>线程类的构造方法、静态块是被哪个线程调用</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#获取一份线程dump文件方法" class="sidebar-link reco-side-获取一份线程dump文件方法" data-v-b57cc07c>获取一份线程dump文件方法</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#new-对象执行步骤" class="sidebar-link reco-side-new-对象执行步骤" data-v-b57cc07c>new   对象执行步骤</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#synchronized" class="sidebar-link reco-side-synchronized" data-v-b57cc07c>synchronized</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#synchronized、volatile、cas" class="sidebar-link reco-side-synchronized、volatile、cas" data-v-b57cc07c>synchronized、volatile、cas</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#synchronized和lock区别" class="sidebar-link reco-side-synchronized和lock区别" data-v-b57cc07c>synchronized和lock区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#synchronized-和reentrantlock区别" class="sidebar-link reco-side-synchronized-和reentrantlock区别" data-v-b57cc07c>synchronized 和ReentrantLock区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#volatile" class="sidebar-link reco-side-volatile" data-v-b57cc07c>volatile</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#final-2" class="sidebar-link reco-side-final-2" data-v-b57cc07c>final</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#lock" class="sidebar-link reco-side-lock" data-v-b57cc07c>lock</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#乐观锁和悲观锁" class="sidebar-link reco-side-乐观锁和悲观锁" data-v-b57cc07c>乐观锁和悲观锁</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#cas" class="sidebar-link reco-side-cas" data-v-b57cc07c>CAS</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#活锁和饥饿" class="sidebar-link reco-side-活锁和饥饿" data-v-b57cc07c>活锁和饥饿</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#aqs" class="sidebar-link reco-side-aqs" data-v-b57cc07c>AQS</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#readwritelock" class="sidebar-link reco-side-readwritelock" data-v-b57cc07c>ReadWriteLock</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#concurrenthashmap" class="sidebar-link reco-side-concurrenthashmap" data-v-b57cc07c>ConcurrentHashMap</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#并发容器实现" class="sidebar-link reco-side-并发容器实现" data-v-b57cc07c>并发容器实现</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#synchronizedmap和concurrenthashmap区别" class="sidebar-link reco-side-synchronizedmap和concurrenthashmap区别" data-v-b57cc07c>synchronizedMap和ConcurrentHashMap区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#copyonwritearraylist" class="sidebar-link reco-side-copyonwritearraylist" data-v-b57cc07c>CopyOnWriteArrayList</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#threadlocal" class="sidebar-link reco-side-threadlocal" data-v-b57cc07c>ThreadLocal</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#阻塞队列" class="sidebar-link reco-side-阻塞队列" data-v-b57cc07c>阻塞队列</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程池" class="sidebar-link reco-side-线程池" data-v-b57cc07c>线程池</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#线程组" class="sidebar-link reco-side-线程组" data-v-b57cc07c>线程组</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#threadpoolexecutor" class="sidebar-link reco-side-threadpoolexecutor" data-v-b57cc07c>ThreadPoolExecutor</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#并发工具类countdownlatch和cyclibarriar的区别" class="sidebar-link reco-side-并发工具类countdownlatch和cyclibarriar的区别" data-v-b57cc07c>并发工具类CountDownLatch和CycliBarriar的区别</a></li><li class="level-2" data-v-b57cc07c><a href="/study/pages/interview/#常用并发工具类" class="sidebar-link reco-side-常用并发工具类" data-v-b57cc07c>常用并发工具类</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/study/assets/js/app.4dbd6f0e.js" defer></script><script src="/study/assets/js/3.9cc2d08d.js" defer></script><script src="/study/assets/js/1.66bfa7cb.js" defer></script><script src="/study/assets/js/21.23c92e60.js" defer></script>
  </body>
</html>
