(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{429:function(_,v,l){"use strict";l.r(v);var i=l(2),t=Object(i.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"mesi-缓存一致性约束"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mesi-缓存一致性约束"}},[_._v("#")]),_._v(" MESI（缓存一致性约束）")]),_._v(" "),v("ul",[v("li",[_._v("M(modify) 修改:处于该状态的缓存行已经被当前CPU修改，且必须刷新到主存中")]),_._v(" "),v("li",[_._v("E(Exclusive) 独占:处于该状态的缓存行只是被当前CPU读取，但是没有进行修改，可被抛弃")]),_._v(" "),v("li",[_._v("S(Shared) 共享:处于该状态的缓存行至少被两个或者两个以上的CPU读取，且数据和主存中的一致")]),_._v(" "),v("li",[_._v("I(Invalid) 作废:处于该状态的缓存行表示已经失效了")])]),_._v(" "),v("p",[v("strong",[_._v("cpu读请求：")]),_._v(" ：处于MES状态下的数据才能被读取，I状态下的数据必须从主存中重新读取")]),_._v(" "),v("p",[v("strong",[_._v("CPU写请求：")]),_._v("：处于ME状态下的数据才能被写，处于S状态下的数据必须把其他CPU的缓存行数据设置为I状态后才能被写")]),_._v(" "),v("p",[v("strong",[_._v("CPU存储缓冲区")]),_._v("：在CPU和主存之间又引入了存储缓冲区的概念，同时又引入了可见性问题")]),_._v(" "),v("ul",[v("li",[_._v("解决方法：使用CPU内存屏障来禁止cpu指令重排序\n"),v("ul",[v("li",[_._v("写屏障：通知处理器在写屏障之前的所有已经存储在存储缓冲区内的数据全部刷新到主存中，作用是使得写屏障之前的指令对写屏障之后的操作是可见的")]),_._v(" "),v("li",[_._v("读屏障：处理器在读屏障之后的操作都在读屏障之后执行，配合写屏障，使得写屏障之前的内存更新对于读屏障之后的操作是可见的")]),_._v(" "),v("li",[_._v("全屏障：确保屏障前的内存读写操作的结果都提交到内存之后，再执行屏障之后的读写操作")])])])]),_._v(" "),v("p",[v("strong",[_._v("JMM层面的内存屏障")])]),_._v(" "),v("ul",[v("li",[_._v("LoadLoad：确保屏障之前的数据装载操作都先于屏障之后的所有指令的数据装载")]),_._v(" "),v("li",[_._v("StoreStore：确保屏障之前的数据都刷新到主存，对于屏障之后的存储指令的存储")]),_._v(" "),v("li",[_._v("LoadStore：确保屏障之前的数据装载都先于屏障之后的存储指令刷新到内存")]),_._v(" "),v("li",[_._v("StoreLoad：确保屏障之前的所有数据对其他处理器可见（指刷新到内存），且都优先于屏障之后的所有装载指令的装载，该屏障会等待屏障之前的所有内存访问指令都执行完才会执行屏障之后的内存访问指令")])]),_._v(" "),v("h2",{attrs:{id:"零拷贝"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#零拷贝"}},[_._v("#")]),_._v(" 零拷贝")]),_._v(" "),v("ul",[v("li",[_._v("物理内存：通过物理内存条获取的内存空间")]),_._v(" "),v("li",[_._v("虚拟内存：计算机内存管理的一种技术，使得每个用户进程有一个完整的内存空间，实际上虚拟内存通常被分割为多个物理内存碎片，还有暂部分存储在外部磁盘存储器上，虚拟内存和用户进程紧密相关，每个进程都维护一个单独的虚拟内存和物理内存的映射页表")]),_._v(" "),v("li",[_._v("内核空间：内核空间总是驻留在内存中，它为操作系统的内核保留，应用程序不允许在此区域内读写或直接调用系统函数\n"),v("ul",[v("li",[_._v("进程私有虚拟空间：每个进程都有单独的内核栈、页表、task结构和mem_map结构")]),_._v(" "),v("li",[_._v("进程共享虚拟空间：属于所有内核态进程共享的内存区域，包括物理存储器、内核数据和内核代码区域")])])]),_._v(" "),v("li",[_._v("用户空间：每一个用户进程都拥有一个单独的用户空间，处于用户态的进程不能访问内核空间的数据，也不能直接调用系统函数，需要使用是要将进程切换为内核态\n"),v("ul",[v("li",[_._v("运行时栈：由编译器自动释放，存放函数的参数值，局部变量和方法返回值")]),_._v(" "),v("li",[_._v("运行时堆：用于存放进程运行中被分配的内存段，位于BSS和栈中间的地址位，由开发人员申请分配和释放")]),_._v(" "),v("li",[_._v("代码段：存放CPU可以执行的机器指令，该部分内存只能读不能写，通常代码区是共享的，即其他执行程序可以调用它，如机器中有数个进程运行同一个程序，那么它们就可以共用一个代码段")]),_._v(" "),v("li",[_._v("未初始化的数据段：存放未初始化的全局变量，BSS的数据在程序开始之前被初始化为0或者null")]),_._v(" "),v("li",[_._v("已初始化的数据段：存放已初始化的全局变量，包括静态变量、静态局部变量和常量")]),_._v(" "),v("li",[_._v("内存映射区域：例如将动态库，共享内存等虚拟空间的内存映射到物理内存，一般是mmap函数所分配的虚拟内存")])])]),_._v(" "),v("li",[_._v("Linux内部层级结构：内核态可以执行任何命令，调用系统一切资源，而用户态只能执行简单的运算，不能直接调用系统资源。用户态必须通过系统接口（System Call），才能向内核发出指令\n"),v("ul",[v("li",[_._v("内核空间可以访问所有的CPU指令和所有的内存空间、I/O空间和硬件设备")]),_._v(" "),v("li",[_._v("用户空间只能访问受限的资源，如果需要特殊权限，可以通过系统调用获得相应的资源")]),_._v(" "),v("li",[_._v("用户空间允许页面中断，而内核空间不允许")]),_._v(" "),v("li",[_._v("所有内核进程（线程）共用一个地址，而用户进程都有各自的地址空间")]),_._v(" "),v("li",[_._v("层级结构从最底层到最上层依次为：硬件、内核空间、用户空间")])])]),_._v(" "),v("li",[_._v("LinuxI/O读写方式\n"),v("ul",[v("li",[_._v("轮询：基于死循环对I/O端口进行不断检测")]),_._v(" "),v("li",[_._v("I/O中断：指当数据到达时，磁盘主动向CPU发起中断请求，由CPU自身负责数据的传输过程")]),_._v(" "),v("li",[_._v("DMA：在I/O中断的基础上引入DMA磁盘控制器，由DMA磁盘控制器负责数据的传输")])])]),_._v(" "),v("li",[_._v("IO中断原理\n"),v("ul",[v("li",[_._v("用户进程向CPU发起read系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回")]),_._v(" "),v("li",[_._v("CPU在接收到指令之后对磁盘发起I/O请求，将磁盘数据先放入磁盘缓冲区")]),_._v(" "),v("li",[_._v("数据准备完之后，磁盘向CPU发起I/O中断")]),_._v(" "),v("li",[_._v("CPU接收到I/O中断之后将磁盘缓冲区中的数据拷贝到内核缓冲区，然后再从内核缓冲区拷贝到用户缓冲区")]),_._v(" "),v("li",[_._v("用户进程由内核态切换为用户态，解除阻塞状态，然后等待CPU的下一个执行时间钟")])])]),_._v(" "),v("li",[_._v("DMA传输原理：全称叫直接内存存取（Direct Memory Access），是一种允许外围设备（硬件子系统）直接访问系统主存的机制，也就是说系统主内存于硬盘或网卡之间的数据传输可以绕开CPU的全程调度\n"),v("ul",[v("li",[_._v("用户进程向CPU发起read系统调用读取数据，由用户态切换为内核态，然后一直阻塞等待数据的返回")]),_._v(" "),v("li",[_._v("CPU在接收到指令之后对DMA磁盘控制器发起调度指令")]),_._v(" "),v("li",[_._v("DMA磁盘控制器对磁盘发起I/O请求，将磁盘数据放入到磁盘控制器缓冲区，CPU全程不参与此过程")]),_._v(" "),v("li",[_._v("数据读取完成后，DMA会接收到磁盘的通知，将数据从磁盘缓冲区拷贝到内核缓冲区")]),_._v(" "),v("li",[_._v("DMA磁盘控制器向CPU发出数据读完的信号，由CPU负责将数据从内核缓冲区拷贝到用户缓冲区")]),_._v(" "),v("li",[_._v("用户进程由内核态切换为用户态，解除阻塞状态，然后等待下一个CPU执行时间钟")])])]),_._v(" "),v("li",[_._v("零拷贝方案\n"),v("ul",[v("li",[_._v("用户态直接IO：应用进程在用户态时直接使用运行在用户态下的库函数直接访问硬件设备，数据直接跨过内核进行传输，内核在数据传输过程除了进行必要的虚拟存储之外，不参与任何其他工作，这种方式直接绕过内核，极大的提高了性能。这种模式只适用于不需要内核缓冲区处理的程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称之为自缓存应用程序，如数据库管理系统。其次，这种零拷贝机制会直接操作磁盘IO，由于CPU和磁盘IO之间的执行时间差距，会造成大量的资源浪费，解决方案是配合异步IO使用")]),_._v(" "),v("li",[_._v("mmap+write：是一种Linux提供的内存映射方法，即将一个进程的地址空间中的一段虚拟地址映射到磁盘文件地址，使用mmap的目的是将内核中读缓冲区的地址与用户空间的缓冲区进行映射，从而实现内核缓冲区和应用程序内存的共享\n"),v("ul",[v("li",[_._v("用户进程通过mmap函数向内核发起系统调用，上下文从用户态切换为内核态")]),_._v(" "),v("li",[_._v("将用户进程的内核空间的读缓冲区与用户空间的缓冲区进行内存地址映射")]),_._v(" "),v("li",[_._v("CPU利用DMA控制器将数据从主存或硬盘中拷贝到内核空间的读缓冲区")]),_._v(" "),v("li",[_._v("上下文从内核态切换为用户态，mmap系统调用执行返回")]),_._v(" "),v("li",[_._v("用户态进程通过write（）函数向内核发起系统调用，上下文从用户态切换为内核态")]),_._v(" "),v("li",[_._v("CPU将读缓冲区中的数据拷贝到网络缓冲区（socket buffer）")]),_._v(" "),v("li",[_._v("CPU利用DMA控制器将数据从网络缓冲区拷贝到网卡进行数据传输")]),_._v(" "),v("li",[_._v("上下文从内核态转化为用户态，write系统调用执行返回")]),_._v(" "),v("li",[v("strong",[_._v("mmap作用")]),_._v("：主要是提高IO性能，特别是针对大文件，对于小文件，内存映射文件反而会导致碎片空间的浪费，因为内存映射总是要对齐页边界")]),_._v(" "),v("li",[v("strong",[_._v("mmap副作用")]),_._v("：当mmap一个文件时，如果这个文件被另一个进程所截获，那么write系统调用会因为访问非法地址被SIGBUS信号终止，SIGBUS默认会杀死进程并产生一个coredump，服务器因此可能被终止")])])]),_._v(" "),v("li",[_._v("sendfile：通过sendfile系统调用，数据可以直接在内核空间内部进行I/O传输，从而省去了数据在内核缓冲区和用户缓冲区进行拷贝，与mmap不同的是，sendfile调用中I/O数据对用户空间是完全不可见的，是一次完全意义上的数据传输过程\n"),v("ul",[v("li",[_._v("用户进程通过sendfile函数向内核发起系统调用，上下文从用户态切换为内核态")]),_._v(" "),v("li",[_._v("CPU利用DMA控制器将数据从主存或硬盘缓冲区拷贝到网络缓冲区（socket buffer）")]),_._v(" "),v("li",[_._v("CPU利用DMA控制器将数据从网络缓冲区拷贝到网卡进行数据传输")]),_._v(" "),v("li",[_._v("上下文从内核态切换为用户态，sendfile系统调用执行返回")]),_._v(" "),v("li",[v("strong",[_._v("sendfile作用")]),_._v("：减少了2次上下文切换，仍然还有一次cpu数据拷贝")]),_._v(" "),v("li",[v("strong",[_._v("sendfile副作用")]),_._v("：用户程序不能修改数据，只是单纯的完成一次数据传输")])])]),_._v(" "),v("li",[_._v("sendfile+DMA gather copy：DMA引入了gather操作，它将内核空间的读缓冲区中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区中，由DMA根据内存地址、地址偏移量将数据批量的从读缓冲区拷贝到网卡设备中\n"),v("ul",[v("li",[_._v("用户进行通过sendfile函数向内核发起系统调用，上下文从用户态切换为内核态")]),_._v(" "),v("li",[_._v("CPU利用DMA控制器将数据从主存或者硬盘缓冲区拷贝到内核空间的读缓冲区")]),_._v(" "),v("li",[_._v("CPU把读缓冲区的文件描述符和数据长度拷贝到网络缓冲区")]),_._v(" "),v("li",[_._v("基于已经拷贝的文件描述符和数据长度，CPU利用DMA控制器的gather/scatter操作直接批量的将数据从内核的读缓冲区拷贝到网卡进行数据传输")]),_._v(" "),v("li",[_._v("上下文从内核态切换为用户态，sendfile系统调用执行返回")]),_._v(" "),v("li",[v("strong",[_._v("副作用")]),_._v("：和之前的一样，用户同样不能修改数据，而且本身需要硬件的支持，只适用于将数据从文件拷贝到socket套接字上的传输过程")])])]),_._v(" "),v("li",[_._v("splice：在内核空间的读缓冲区和网络缓冲区之间建立管道，从而避免CPU拷贝操作\n"),v("ul",[v("li",[_._v("用户进程通过splice函数向内核发起系统调用，上下文从用户态切换为内核态")]),_._v(" "),v("li",[_._v("CPU利用DMA控制器将数据从主存或硬盘拷贝到内核缓冲区的读缓冲区")]),_._v(" "),v("li",[_._v("CPU在内核读缓冲区和网络缓冲区之间建立管道")]),_._v(" "),v("li",[_._v("CPu利用DMA控制器将网络缓冲区的数据拷贝到网卡进行传输")]),_._v(" "),v("li",[_._v("上下文从内核态切换为用户态，splice系统调用执行返回")]),_._v(" "),v("li",[v("strong",[_._v("splice副租用")]),_._v("：同样是用户不能进行数据的修改，除此之外，它使用了Linux的管道缓冲机制，可以用于任意两个文件描述符中传输数据，但是它的两个文件描述符参数据中有一个必须是管道设备")])])]),_._v(" "),v("li",[_._v("缓冲区共享（solaris fbuf）：每个进程都维护着一个缓冲区池，这个缓冲区池可以同时映射到用户空间和内核态，内核和用户共享该缓冲区池\n"),v("ul",[v("li",[v("strong",[_._v("目前进展")]),_._v("：缓冲区池管理需要应用程序、网络软件以及设备驱动程序之间的紧密合作，如何改写APi目前还处于试验阶段并不成熟")])])])])]),_._v(" "),v("li",[_._v("写实复制：当多个进程共享同一块数据时，如果其中一个进程需要对数据进行修改，那么就需要将其拷贝到自己的进程地址空间，这样做并不影响其他进程对这块数据的操作，每个进行在需要修改数据的时候才会进行拷贝")])]),_._v(" "),v("h2",{attrs:{id:"操作系统原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#操作系统原理"}},[_._v("#")]),_._v(" 操作系统原理")]),_._v(" "),v("ul",[v("li",[_._v("CPU指令权限分级\n"),v("ul",[v("li",[_._v("Inter CPU：分为ring0、ring1、ring2、ring3四个等级，其中ring0权限最高，可以操作所有计算机资源，ring3权限最低，不能使用访问硬件资源的指令，如IO读写、网卡访问等")]),_._v(" "),v("li",[_._v("Linux 系统：采用ring0和ring3两个等级，其中ring0被叫做内核态，完全在操作系统内核中运行，由专门的内核线程在CPU中执行任务；ring3被叫做用户态，在应用程序中运行，由用户线程在CPU中执行其任务")])])]),_._v(" "),v("li",[_._v("进程："),v("strong",[_._v("系统调度资源的最小或基本单位")]),_._v("，其本质是一段记录专有资源和状态的task_struct结构体，这个结构体也叫"),v("strong",[_._v("PCB（process control block）")]),_._v("，如下结构体的属性成员\n"),v("ul",[v("li",[_._v("标识符：与进程相关的唯一标识符，用来区别正在执行的进程和其他进程")]),_._v(" "),v("li",[_._v("状态：描述进程的状态，进程状态有运行、阻塞、挂起、就绪、创建、终止。")]),_._v(" "),v("li",[_._v("优先级：标明进程执行顺序的优先级")]),_._v(" "),v("li",[_._v("程序计数器：程序中即将被执行的下一条指令的地址")]),_._v(" "),v("li",[_._v("内存指针：程序代码和进程相关数据的指针")]),_._v(" "),v("li",[_._v("上下文数据：进程执行时处理器中寄存器的数据")]),_._v(" "),v("li",[_._v("I/O状态信息：包括显示的IO请求，分配给进程的IO设备和被进程使用的文件列表")]),_._v(" "),v("li",[_._v("记账信息：包括处理器的时间总和，记账号等")])])]),_._v(" "),v("li",[_._v("线程："),v("strong",[_._v("竞争CPU资源的基本单位")]),_._v("，和进程一样，也是一个task_struct结构体,这个结构体也叫"),v("strong",[_._v("TCB（Thread control block）")]),_._v("，线程new出来之后就是把进程的PCB复制一份给自己，然后加上PCB没有的pc程序计数器、sp堆栈、state状态、寄存器这些信息")])])])}),[],!1,null,null,null);v.default=t.exports}}]);