(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{442:function(v,_,i){"use strict";i.r(_);var l=i(2),a=Object(l.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"jvm组成和作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm组成和作用"}},[v._v("#")]),v._v(" jvm组成和作用")]),v._v(" "),_("ul",[_("li",[v._v("类加载器（ClassLoader）")]),v._v(" "),_("li",[v._v("运行时数据区（Runtime Data Area）")]),v._v(" "),_("li",[v._v("执行引擎（Execution Engine）")]),v._v(" "),_("li",[v._v("本地库接口（Native Interface）")])]),v._v(" "),_("h3",{attrs:{id:"作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[v._v("#")]),v._v(" 作用")]),v._v(" "),_("ul",[_("li",[v._v("首先通过**类加载器（ClassLoader）**把 java 代码转换成字节码")]),v._v(" "),_("li",[v._v("**运行时数据区（Runtime Data Area）**再把字节码加载到内存中，字节码文件只是 jvm 的一套指令集规范，并不能直接交给底层操作系统去执行")]),v._v(" "),_("li",[v._v("因此需要特定的命令解析器"),_("strong",[v._v("执行引擎（Execution Engine）")]),v._v("，将字节码翻译成底层系统指令，交由 CPU 去执行")]),v._v(" "),_("li",[v._v("这个过程中需要调用其他语言的**本地库接口（Native Interface）**来实现整个程序的功能")])]),v._v(" "),_("h3",{attrs:{id:"jmm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jmm"}},[v._v("#")]),v._v(" JMM")]),v._v(" "),_("ul",[_("li",[v._v("Java 线程之间的通信由 Java 内存模型（JMM Java memory model）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。")])]),v._v(" "),_("h2",{attrs:{id:"jvm-虚拟机"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm-虚拟机"}},[v._v("#")]),v._v(" JVM（虚拟机）")]),v._v(" "),_("ul",[_("li",[v._v("结构\n"),_("ul",[_("li",[v._v("运行时数据区（Runtime Data Area）\n"),_("ul",[_("li",[v._v("线程共享\n"),_("ul",[_("li",[v._v("方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据")]),v._v(" "),_("li",[v._v("堆：jvm内存中最大的一块，主要是存放对象实例和数组")])])]),v._v(" "),_("li",[v._v("线程私有\n"),_("ul",[_("li",[v._v("本地方法栈：是为虚拟机使用到的Native方法服务")]),v._v(" "),_("li",[v._v("虚拟机栈：生命周期和线程一致，描述的是Java方法执行的内存模型，每个方法执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用到执行结束，就代表着一个栈帧从虚拟机栈中从入栈到出栈的过程")]),v._v(" "),_("li",[v._v("程序计数器：字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支，循环、跳转、异常处理、线程恢复等基础功能。")])])])])]),v._v(" "),_("li",[v._v("执行引擎")]),v._v(" "),_("li",[v._v("本地接口")]),v._v(" "),_("li",[v._v("本地方法库")])])]),v._v(" "),_("li",[v._v("分区\n"),_("ul",[_("li",[v._v("堆中分区：被划分为新生代和老年代，其中新生代又被划分为Eden，from Survivor和to Survivor区")]),v._v(" "),_("li",[v._v("分区比例：新生代和老年代默认大小比例为1:2，默认的，Eden、form Suvivor和to Survivor比例为8:1:1，且无论何时，总有一块Survivor区域是空闲的")]),v._v(" "),_("li",[v._v("永久代：指的是jvm的方法区")]),v._v(" "),_("li",[v._v("好处：根据各个年代特点进行分区对象存储，便于回收，采用适当的回收算法，新生代中大量的对象死去，只有少量对象存活，所以一般采用复制算法，而老年代对象存活率高，所以采用标记清理或者标记整理算法")])])]),v._v(" "),_("li",[v._v("GC方式\n"),_("ul",[_("li",[v._v("Minor GC：新生代GC，指的是发生在新生代的垃圾回收动作，所以比较频繁，回收速度也快")]),v._v(" "),_("li",[v._v("Major GC：老年代GC，指的是发声在老年代的垃圾回收动作，Major GC一般也伴随着Minor GC一起执行，所以回收速度要比Minor GC慢的多")]),v._v(" "),_("li",[v._v("Full  GC：清理整个堆空间，包括新生代和老年代")]),v._v(" "),_("li",[v._v("触发条件：Minor GC是当Eden区满的时候会触发，Major GC和Full GC通常是等价的，触发条件是每次晋升到老年代的对象平均大小大于老年代剩余空间\nMinor GC后存活的对象超过了老年代剩余的空间、永久代空间不足、执行System.gc()、CMS GC异常、堆内存分配很大的对象")])])]),v._v(" "),_("li",[v._v("判断对象存活方法\n"),_("ul",[_("li",[v._v("引用计数法：如果一个对象没有被任何引用指向，就可以视为垃圾，缺点就是无法解决循环引用的情况")]),v._v(" "),_("li",[v._v("可达性分析法：从GC Root开始向下搜索，搜索走过的引用链，当一个对象到GC Root没有任何引用链，则证明该对象是不可用的，这是主流虚拟机采用的算法")])])]),v._v(" "),_("li",[v._v("垃圾回收算法\n"),_("ul",[_("li",[v._v("标记清除算法：分为两阶段，其中一阶段为标记，标记对象是否存活或者死亡，二阶段为清除，清除那些标记已死亡的对象")]),v._v(" "),_("li",[v._v("标记整理算法：标记清除算法的改良版，一阶段不变，二阶段会把所有已经存活的对象整理存放到另一个空间，然后把剩下的对象全部清除")]),v._v(" "),_("li",[v._v("复制算法：该算法把内存分为两部分，每次使用只使用一部分，当这部分满的时候，将内存中存活的对象复制到另一个空间，然后将之前使用的内存清空")]),v._v(" "),_("li",[v._v("算法优缺点：标记清除算法清除效率高，但是会造成内存碎片；标记整理不会造成内存碎片，但是由于移动了对象，需要更新引用，复制算法不需要更新引用，但是会造成内存浪费")]),v._v(" "),_("li",[v._v("使用场景：标记清除和标记整理一般都应用于老年代，因为老年代对象生命周期都比较长，复制算法一般应用于新生代，因为新生代存活对象并不多")])])]),v._v(" "),_("li",[v._v("垃圾收集器\n"),_("ul",[_("li",[v._v("新生代收集器\n"),_("ul",[_("li",[v._v("Serial：使用复制算法，单线程，Client模式下默认新生代收集器，简单高效")]),v._v(" "),_("li",[v._v("ParNew：使用复制算法，多线程，Serial的多线程版本，Server模式下的首选，可搭配CMS的新生代收集器")]),v._v(" "),_("li",[v._v("Parallel Scavenge：使用复制算法，多线程，目标是达到可控制的吞吐量")])])]),v._v(" "),_("li",[v._v("老年代收集器\n"),_("ul",[_("li",[v._v("CMS：使用标记清除算法，多线程，追求最短回收停顿时间")]),v._v(" "),_("li",[v._v("Serial Old：使用标记整理算法，多线程，Serial老年代版本，给Client模式下的虚拟机使用")]),v._v(" "),_("li",[v._v("Parallel Old：使用标记整理算法，多线程，paraller Scavenge 老年代版本，吞吐量有限")])])]),v._v(" "),_("li",[v._v("整堆收集器\n"),_("ul",[_("li",[v._v("G1：使用标记整理+复制算法，多线程，JDK1.9默认垃圾收集器")])])])])]),v._v(" "),_("li",[v._v("参数配置\n"),_("ul",[_("li",[_("p",[v._v("常用的设置")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("-Xms：初始堆大小，JVM 启动的时候，给定堆空间大小。")])]),v._v(" "),_("li",[_("p",[v._v("-Xmx：最大堆大小，JVM 运行过程中，如果初始堆空间不足的时候，最大可以扩展到多少。")])]),v._v(" "),_("li",[_("p",[v._v("-Xmn：设置堆中年轻代大小。整个堆大小=年轻代大小+年老代大小+持久代大小。")])]),v._v(" "),_("li",[_("p",[v._v("-XX:NewSize=n 设置年轻代初始化大小大小")])]),v._v(" "),_("li",[_("p",[v._v("-XX:MaxNewSize=n 设置年轻代最大值")])]),v._v(" "),_("li",[_("p",[v._v("-XX:NewRatio=n 设置年轻代和年老代的比值。如: -XX:NewRatio=3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代+年老代和的 1/4")])]),v._v(" "),_("li",[_("p",[v._v("-XX:SurvivorRatio=n 年轻代中 Eden 区与两个 Survivor 区的比值。注意 Survivor 区有两个。8表示两个Survivor :eden=2:8 ,即一个Survivor占年轻代的1/10，默认就为8")])]),v._v(" "),_("li",[_("p",[v._v("-Xss：设置每个线程的堆栈大小。JDK5后每个线程 Java 栈大小为 1M，以前每个线程堆栈大小为 256K。")])]),v._v(" "),_("li",[_("p",[v._v("-XX:ThreadStackSize=n 线程堆栈大小")])]),v._v(" "),_("li",[_("p",[v._v("-XX:PermSize=n 设置持久代初始值")])]),v._v(" "),_("li",[_("p",[v._v("-XX:MaxPermSize=n 设置持久代大小")])]),v._v(" "),_("li"),v._v(" "),_("li",[_("p",[v._v("-XX:MaxTenuringThreshold=n 设置年轻带垃圾对象最大年龄。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。")])])])]),v._v(" "),_("li",[_("p",[v._v("下面是一些不常用的")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("-XX:LargePageSizeInBytes=n 设置堆内存的内存页大小")])]),v._v(" "),_("li",[_("p",[v._v("-XX:+UseFastAccessorMethods 优化原始类型的getter方法性能")])]),v._v(" "),_("li",[_("p",[v._v("-XX:+DisableExplicitGC 禁止在运行期显式地调用System.gc()，默认启用")])]),v._v(" "),_("li",[_("p",[v._v("-XX:+AggressiveOpts 是否启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等，jdk6纸之后默认启动")])]),v._v(" "),_("li",[_("p",[v._v("-XX:+UseBiasedLocking 是否启用偏向锁，JDK6默认启用")])]),v._v(" "),_("li",[_("p",[v._v("-Xnoclassgc 是否禁用垃圾回收")])]),v._v(" "),_("li",[_("p",[v._v("-XX:+UseThreadPriorities 使用本地线程的优先级，默认启用")])])])])])])]),v._v(" "),_("h2",{attrs:{id:"jvm调优步骤"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优步骤"}},[v._v("#")]),v._v(" JVM调优步骤")]),v._v(" "),_("ul",[_("li",[v._v("第一步：监控分析GC日志")]),v._v(" "),_("li",[v._v("第二步：判断JVM问题：\n"),_("ul",[_("li",[v._v("如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么就没有必要进行GC优化")]),v._v(" "),_("li",[v._v("如果GC时间超过1到3秒或者频繁GC，则必须优化")])])]),v._v(" "),_("li",[v._v("第三步：确定调优目标")]),v._v(" "),_("li",[v._v("第四步：调整参数\n"),_("ul",[_("li",[v._v("一般从满足程序的内存使用需求开始，之后是时间延迟要求，最后才是吞吐量要求，要基于这个步骤来不断优化，每一个步骤都是进行下一个步骤的基础，不可逆行之")])])]),v._v(" "),_("li",[v._v("第五步：对比调优前后差距")]),v._v(" "),_("li",[v._v("第六步：重复1/2/3/4/5步骤\n"),_("ul",[_("li",[v._v("找到最佳JVM参数设置")])])]),v._v(" "),_("li",[v._v("第七步：应用JVM到应用服务器\n"),_("ul",[_("li",[v._v("找到最合适的参数，将这些参数应用到所有的服务器，并进行后续跟踪")])])]),v._v(" "),_("li",[_("strong",[v._v("调优参数典型设置")]),v._v(" "),_("ul",[_("li",[v._v("-Xms 堆内存的最小值：默认情况下，当堆中可用内存小于40%时，堆内存会开始增加，一直增加到-Xmx的大小。")]),v._v(" "),_("li",[v._v("-Xmx 堆内存的最大值：默认情况下，当堆中可用内存大于70%时，堆内存会开始减小，一直减小到-Xms的大小。")]),v._v(" "),_("li",[v._v("-Xmn 新生代内存的最大值：包括Eden区和两个Survivor区的总和，配置写法如：-Xmn 1024k、-Xmn 1g、-Xmn 1024m")]),v._v(" "),_("li",[v._v("-Xss 每个线程的栈内存：默认1m，一般来说不需要改，线程栈越小意味着可以创建更多的线程数")]),v._v(" "),_("li",[v._v("整个堆大小等于年轻代+年老代大小，默认为年老代/年轻代为2/1，在开发环境中可以设置堆内存最小和最大值不同，在线上环境堆内存最小和最大值应该设置一样，防止抖动")]),v._v(" "),_("li",[v._v("-XX：+PrintGCDetails：开启GC日志创建更详细的GC日志，默认情况下GC日志是关闭的")]),v._v(" "),_("li",[v._v("-XX：+PrintGCTimeStamps，-XX：PrintGCDateStamps：开启GC时间提示\n"),_("ul",[_("li",[v._v("开启时间便于我们更精确的判断几次GC操作之间的时间")]),v._v(" "),_("li",[v._v("时间戳是相对于0（依据JVM启动时间）的值，而日期戳（Stamps）是实际的日期字符串")])])]),v._v(" "),_("li",[v._v("-XX：+PrintHeapAtGC：打印堆的GC日志")]),v._v(" "),_("li",[v._v("-Xloggc：./logs/gc.log：指定GC日志路径")])])])])])}),[],!1,null,null,null);_.default=a.exports}}]);