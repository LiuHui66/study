(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{439:function(t,a,e){"use strict";e.r(a);var s=e(2),r=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"网络io的耗时跟磁盘io耗时差不多-也是在微秒级别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网络io的耗时跟磁盘io耗时差不多-也是在微秒级别"}},[t._v("#")]),t._v(" 网络IO的耗时跟磁盘IO耗时差不多，也是在微秒级别")]),t._v(" "),a("h2",{attrs:{id:"什么是socket"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是socket"}},[t._v("#")]),t._v(" 什么是Socket")]),t._v(" "),a("blockquote",[a("p",[t._v("socket是在应用层和传输层中间的抽象层，它把传输层（TCP/UDP）的复杂操作抽象成一些简单的接口，供应用层调用实现进程在网络中的通信。")])]),t._v(" "),a("h2",{attrs:{id:"socket设计的目的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#socket设计的目的"}},[t._v("#")]),t._v(" Socket设计的目的")]),t._v(" "),a("blockquote",[a("p",[t._v("传输到目标计算机后，操作系统内核通过网卡读取网络数据，将网络数据存储在内存中。计算机中会运行不同的网络程序，他们可能对应于系统中的不同进程，那要如何把网卡中的网络数据识别出来是给哪个进程的，要如何持续和稳定地给到对应的应用进程呢？我想这也就是socket设计的目的和想要解决的问题了，提供一些API接口来实现应用层通过操作系统内核读取网卡数据，并且将网络数据正确地分发到对应的应用层程序。")])]),t._v(" "),a("h2",{attrs:{id:"服务端处理网络io过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端处理网络io过程"}},[t._v("#")]),t._v(" 服务端处理网络IO过程")]),t._v(" "),a("ul",[a("li",[t._v("（1）成功建立连接。")]),t._v(" "),a("li",[t._v("（2）内核等待网卡数据到位。（这里涉及DMA技术）(这一步控制IO是否阻塞)")]),t._v(" "),a("li",[t._v("（3）内核缓冲区数据拷贝到用户空间（这里涉及mmap内存映射技术）。（这一步控制IO是否同步）")])]),t._v(" "),a("h2",{attrs:{id:"涉及到的知识盲区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#涉及到的知识盲区"}},[t._v("#")]),t._v(" 涉及到的知识盲区")]),t._v(" "),a("h3",{attrs:{id:"dma-直接内存访问-direct-memory-access-指的是数据在内存和io中直接以块形式传输-该技术基于支持dma的硬件实现-且中断由dma设备向cpu发出"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dma-直接内存访问-direct-memory-access-指的是数据在内存和io中直接以块形式传输-该技术基于支持dma的硬件实现-且中断由dma设备向cpu发出"}},[t._v("#")]),t._v(" DMA: 直接内存访问，Direct Memory Access，指的是数据在内存和IO中直接以块形式传输，该技术基于支持DMA的硬件实现，且中断由DMA设备向cpu发出")]),t._v(" "),a("h3",{attrs:{id:"dma工作过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dma工作过程"}},[t._v("#")]),t._v(" DMA工作过程：")]),t._v(" "),a("ul",[a("li",[t._v("（1）当进程要求设备输入数据时，CPU把准备存放输入数据的内存起始地址以及要传送的字节数分别送入DMA控制器中的内存地址寄存器和传送字节计数器。")]),t._v(" "),a("li",[t._v("⑵发出数据传输要求的进行进入等待状态。此时正在执行的CPU指令被暂时挂起，进程进入阻塞状态。进程调度程序调度其他进程占据CPU。")]),t._v(" "),a("li",[t._v("⑶输入设备不断地窃取CPU工作周期（或者说与 CPU 争取内存总线），将数据缓冲寄存器中的数据源源不断地写入内存，直到所要求的字节全部传送完毕。")]),t._v(" "),a("li",[t._v("⑷DMA控制器在传送完所有字节时，通过中断请求线发出中断信号。CPU在接收到中断信号后，转入中断处理程序进行后续处理。")]),t._v(" "),a("li",[t._v("⑸中断处理结束后，CPU返回到被中断的进程中，或切换到新的进程上下文环境中，继续执行。")])]),t._v(" "),a("h3",{attrs:{id:"dma与中断的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dma与中断的区别"}},[t._v("#")]),t._v(" DMA与中断的区别")]),t._v(" "),a("ul",[a("li",[t._v("⑴中断方式是在设备控制器的数据缓冲寄存器满之后发出中断，由设备控制器发出，要求CPU进行中断处理，而DMA方式则是在所要求传送的数据块全部传送结束时要求CPU 进行中断处理，由 DMA 设备发出。这就极大的减少了CPU进行中断处理的次数。")]),t._v(" "),a("li",[t._v("⑵中断方式的数据传送是在中断处理时由CPU控制完成的，而DMA方式则是在DMA控制器的控制下，不经过CPU控制完成的。这就排除了CPU因并行设备过多而来不及处理以及因速度不匹配而造成数据丢失等现象。")])]),t._v(" "),a("h3",{attrs:{id:"mmap-内存映射技术"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mmap-内存映射技术"}},[t._v("#")]),t._v(" MMAP(内存映射技术)")]),t._v(" "),a("blockquote",[a("p",[t._v("用户空间和内核空间映射同一块内存空间，从而达到省略将数据从内核缓冲区拷贝到用户空间的操作，用户空间通过映射直接操作内核缓冲区的数据。")])]),t._v(" "),a("h3",{attrs:{id:"多路复用io"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多路复用io"}},[t._v("#")]),t._v(" 多路复用IO")]),t._v(" "),a("h4",{attrs:{id:"selecter模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#selecter模式"}},[t._v("#")]),t._v(" Selecter模式")]),t._v(" "),a("ul",[a("li",[t._v("select为什么在socket连接很多的情况下性能不佳？")])]),t._v(" "),a("blockquote",[a("p",[t._v("将维护socket监控列表和阻塞进程的操作合并在了一起，每次select()调用都会触发这两个操作，从而导致每次调用select()都需要把全量的fd[]列表从用户空间传递到内核空间，内核线程在阻塞进程前需要遍历fd[]将待阻塞的进程放入到每个fd的等待队列里（第一次遍历）。当有网络数据到来时，并不知道网络数据属于具体哪个socket，只知道收到过网络数据，因此需要遍历fd[]唤醒等待队列里的阻塞进程（第二次遍历），并且把fd[]从内核空间拷贝到用户空间，让用户程序自己去遍历fd[]判别哪个socket收到了网络数据（第三次遍历，发生在用户空间）。fd[]比较大的情况，大量的遍历操作会导致性能急剧下降，所以select会默认限制最大文件句柄数为1024，间接控制fd[]最大为1024。")])]),t._v(" "),a("h4",{attrs:{id:"poll模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#poll模式"}},[t._v("#")]),t._v(" Poll模式：")]),t._v(" "),a("blockquote",[a("p",[t._v("poll其实内部实现基本跟select一样，区别在于它们底层组织fd[]的数据结构不太一样，从而实现了poll的最大文件句柄数量限制去除了")])]),t._v(" "),a("h4",{attrs:{id:"epoll模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#epoll模式"}},[t._v("#")]),t._v(" Epoll模式：")]),t._v(" "),a("blockquote",[a("p",[t._v("引入了eventpoll这个中间结构，它通过红黑树（rbr）来组织所有待监控的socket对象，实现高效的查找，删除和添加。当收到网络数据时，会触发对应的fd的回调函数，这时不是去遍历各个fd的等待队列进行唤醒进程的操作了，而是把收到数据的socket加入到就绪列表（底层是一个双向链表）。eventpoll有个单独的等待队列来维护待唤醒的进程，避免了像select那样每次需要遍历fd[]来查找各个fd的等待队列的进程。")])]),t._v(" "),a("h4",{attrs:{id:"epoll有这几个核心的数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#epoll有这几个核心的数据结构"}},[t._v("#")]),t._v(" epoll有这几个核心的数据结构")]),t._v(" "),a("ul",[a("li",[t._v("红黑树：存放所有待监听的socket")]),t._v(" "),a("li",[t._v("双向链表：存放收到网络数据的socket")]),t._v(" "),a("li",[t._v("等待队列：待唤醒的等待线程")])])])}),[],!1,null,null,null);a.default=r.exports}}]);